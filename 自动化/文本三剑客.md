# 文本三剑客

## 一、通配符

### 通配符

Linux 中的通配符是一种特殊的符号,用于匹配文件名或目录名。这些通配符可以帮助用户更快地输入命令和文件路径。或者可以理解为用户文件名和路径的匹配。由shell进行解析，一般情况下与某些命令配合使用，如：find，cp，mv，ls，rm等。

### **Shell中常见的通配符如下：**

```shell
*: 匹配0或多个字符
?: 匹配任意一个字符
[....]: 匹配方括号中任意单个字符
[!....]: 匹配除了方括号中指定字符之外的字符
范围 [a-z]: 匹配指定范围内的任意一个字符
大括号 {}: 用于匹配由逗号分隔的单个字符串
```

### Shell元字符

在 Shell 脚本中,除了通配符,还有一些特殊的元字符需要了解。这些元字符有特殊的含义,在编写 Shell 脚本时需要特别注意。以下是 Shell 中常见的一些元字符及其用法

```shell
IFSzi：<tab>/<space>/<enter>
=：设定变量
$：取变量值
>/< ：重定向
|：管道
&：后台执行命令
$()/``：在子shell中执行命令/运算或命令替换
{}：用于扩展变量、生成序列等。
例如 echo {A..Z} 会输出 A 到 Z 的大写字母序列。
;：命令结束后，忽略其返回值，继续执行下一个命令
&&：命令结束后，若为true，继续执行下一个命令
||：命令结束后，若为false，继续执行下一个命令
!：非
#：注释
\：转义符
```

**Shell中的转义符：**

```shell
1. 反斜杠 \: 是最常用的转义符,用于转义其后的一个字符
例如 echo "This is a backslash: \\" 会输出 This is a backslash: \
2. 单引号'...': 可以将整个字符串括起来,使其中的特殊字符失去特殊含义，硬转义
3. 双引号"...": 内部的大部分特殊字符仍然保留特殊含义,软转义

示例：
echo 'Hello, $USER'        输出--->  Hello, $USER
echo "Hello, $USER"        输出--->  Hello, root
```



## 二、[find查找](E:\typora\英格\Linux基础\文件基本属性与查找#find)

前面讲过了，这边就不做笔记了



## 三、正则表达式

正则表达式是一种强大的文本匹配和处理工具。它允许你定义复杂的匹配模式,在文本中查找、替换和操作数据。正则表达式被广泛应用于各种文本处理工具和命令中,如 sed、awk、grep 等.....

```bash
1. 字符匹配
- `.`：匹配任意单个字符
- `[]`：匹配指定范围内任意单个字符 `[a-z]` `[0-9]`
- `[^]`：匹配指定范围外任意单个字符 `[^a-z]` `[^0-9]`
- `[:alnum:]`：字母与数字字符
- `[:alpha:]`：字母
- `[:ascii:]`：ASCII 字符
- `[:blank:]`：空格或制表符
- `[:cntrl:]`：ASCII 控制字符
- `[:digit:]`：数字
- `[:graph:]`：非控制、非空格字符
- `[:lower:]`：小写字母
- `[:print:]`：可打印字符
- `[:punct:]`：标点符号字符
- `[:space:]`：空白字符，包括垂直制表符
- `[:upper:]`：大写字母
- `[:xdigit:]`：十六进制数字

2. 匹配次数
- `*`：匹配前面的字符任意次数
- `.*`：匹配任意长度的字符
- `\?`：匹配其前面字符 0 或 1 次，即前面的可有可无 `'a\?b'`
- `\+`：匹配其前面的字符至少 1 次 `'a\+b'`
- `\{m\}`：匹配前面的字符 m 次
- `\{m,n\}`：匹配前面的字符至少 m 次，至多 n 次
- `\{0,n\}`：匹配前面的字符至多 n 次
- `\{m,\}`：匹配前面的字符至少 m 次

3. 位置锚定
- `^`：行首锚定，用于模式的最左侧
- `$`：行末锚定，用于模式的最右侧
- `^PATTERN$`：用于模式匹配整行
- `^$`：空行
- `\<` 或 `\b`：词首锚定，用于单词模式的左侧
- `\>` 或 `\b`：词尾锚定，用于单词模式的右侧
- `\<PATTERN\>`：匹配整个单词 `'\<hello\>'`

4. 分组
- `()`: 用于分组,可以对一组字符应用量词等操作
-  分组括号中的模式匹配到的内容会被正则表达式引擎记录于内部的变量中
-  `\1`、`\2` 等: 用于引用前面匹配的分组内容
-   `\1`:从左侧起，第一个左括号以及与之匹配右括号之间的模式所匹配到的字符；
```



## 四、文本三剑客之grep

grep作用：过滤文本内容

| 选项                     | 描述                                       |
| :----------------------- | :----------------------------------------- |
| -E :--extended--regexp   | 模式是扩展正则表达式（ERE）                |
| -i :--ignore--case       | 忽略大小写                                 |
| -n: --line--number       | 打印行号                                   |
| -o:--only--matching      | 只打印匹配的内容                           |
| -c:--count               | 只打印每个文件匹配的行数                   |
| -B:--before--context=NUM | 打印匹配的前几行                           |
| -A:--after--context=NUM  | 打印匹配的后几行                           |
| -C:--context=NUM         | 打印匹配的前后几行                         |
| --color[=WHEN]           | 匹配的字体颜色，别名已定义了               |
| -v:--invert--match       | 打印不匹配的行                             |
| -e                       | 同时过滤多个匹配项eg：grep -e "^s" -e "s$" |



### 正则表达式（基于grep）

- 功能就是用来检索、替换那些符合某个模式(规则)的文本,正则表达式在每种语言中都会有;
- 正则表达式就是为了处理大量的文本或字符串而定义的一套规则和方法
- 通过定义的这些特殊符号的辅助，系统管理员就可以快速过滤，替换或输出需要的字符串
- Linux正则表达式一般以行为单位处理



### 基础正则表达式

| 符号  | 描述                                             |
| :---: | :----------------------------------------------- |
|   .   | 匹配任意单个字符（必须存在）                     |
|   ^   | 匹配以某个字符开头的行                           |
|   $   | 配以什么字符结尾的行                             |
|   *   | 匹配前面的一个字符出现0次或者多次；eg：a*b       |
|  .*   | 表示任意长度的任意字符                           |
|  []   | 表示匹配括号内的一个字符                         |
|  [^]  | 匹配`[^字符]`之外的任意一个字符                  |
|  []   | 匹配非`[^字符]`内字符开头的行                    |
|   <   | 锚定 单词首部；eg：\<root                        |
|   >   | 锚定 单词尾部：eg：root\>                        |
| {m,n} | 表示匹配前面的字符出现至少m次，至多n次           |
|  ()   | 表示对某个单词进行分组；\1表示第一个分组进行调用 |

### 扩展正则

- egrep ...
- grep -E ...
- 扩展正则支持所有基础正则；并有补充
- 扩展正则中{}和[]不用转义可以直接使用；

| 符号 | 描述                             |
| :--: | :------------------------------- |
|  +   | 表示前面的字符至少出现1次的情况  |
|  \|  | 表示“或”                         |
|  ?   | 表示前面的字符至多出现一次的情况 |



## 五、文本三剑客之sed

（文本处理工具）

sed 是一个强大的文本处理工具,它可以用于对文本进行搜索、替换、删除、插入等操作。

sed主要用来自动编辑一个或多个文件；简化对文件的反复操作；编写转换程序等。

### 语法

```bash
sed的命令格式： sed [option] 'sed command' filename
sed的脚本格式： sed [option] ‐f 'sed script' filename

常用选项：
‐n ：只打印模式匹配的行
‐e ：直接在命令行模式上进行sed动作编辑，此为默认选项
‐f ：将sed的动作写在一个文件内，用–f filename 执行filename内的sed动作
‐r ：支持扩展表达式
‐i ：直接修改文件内容
查询文本的方式
使用行号和行号范围
x：行号
x,y：从x行到y行
x,y!：x行到y行之外
/str：查询包含str的行
/str1/, /str2/：查询包含str1到str2的行
/str/,x：x行内查询包含str的行
x,/str/：x行后查询匹配str的行
```

### 动作说明

```
常用选项：
p：打印匹配的行(‐n)
=：显示文件行号
a\：指定行号后添加新文本
i\：指定行号前添加新文本
d：删除定位行
c\：用新文本替换定位文本
w filename：写文本到一个文件
r filename：从另一个文件读文本
s/要被取代的字串/新的字串（可为空）/标记：替换
替换标记：
g：行内全局替换
p：显示替换成功的行
w：将替换成功的结果保存至指定文件
q：第一个模式匹配后立即退出
{}：在定位行执行的命令组，用逗号分隔
g：将模式2粘贴到/pattern n/
```



## 六、文本三剑客之awk

文本分析工具

awk 是一种编程语言,它可以进行更加复杂的数据处理和分析。



### 使用方法

```bash
awk '{pattern + action}' {filenames}
```

其中 pattern 表示 AWK 在数据中查找的内容，而 action 是在找到匹配内容时所执行的一系列命令。花括号（{}）不需要在程序中始终出现，但它们用于根据特定的模式对一系列指令进行分组。 pattern就是要表示的正则表达式，用斜杠括起来。

awk语言的最基本功能是在文件或者字符串中基于指定规则浏览和抽取信息，awk抽取信息后，才能进行其他文本操作。完整的awk脚本通常用来格式化文本文件中的信息。

通常，awk是以文件的一行为处理单位的。awk每接收文件的一行，然后执行相应的命令，来处理文本。

关注点：**1、分隔符；2、具体的分析（定制化输出、数学与逻辑运算）**



### awk工作原理

执行 awk 时，它依次对/etc/passwd 中的每一行执行 print 命令

awk -F"分隔符" '操作' 文件

cat /etc/passwd | awk -F ".' "{print $1,$3,$4}''

\#以":"为分隔符，输出1，3，4列内容

awk 从输入文件或者标准输入中读入信息，与 sed 一样，信息的读入也是逐行读取的。 不同的是 awk 将文本文件中的一行视为一个记录，而将一行中的某一部分（列）作为记录 中的一个字段（域）。



### 常用 awk 内置变量

| 变量名 | 属性                                |
| ------ | ----------------------------------- |
| $0     | 当前记录                            |
| $1~$n  | 当前记录的第n个字段                 |
| FS     | 输入字段分割符 默认是空格           |
| RS     | 输入记录分割符 默认为换行符         |
| NF     | 当前记录中的字段个数，就是有多少列  |
| NR     | 已经读出的记录数，就是行号，从1开始 |
| OFS    | 输出字段分割符 默认也是空格         |
| ORS    | 输出的记录分割符 默认为换行符       |

用法：

cat /etc/passwd | awk '{print}' #输出所有内容 或者 '{print $0}'

cat /etc/passwd | awk 'NR==1,NR==3{print}' #输出第1~3行内容 

cat /etc/passwd | awk '(NR<=3)$$(NR>=1){print}'



### BEGIN 和 END 模块

1. BEGIN 模块:
   - `BEGIN` 模块是在 awk 开始处理输入数据之前执行的。
   - 它通常用于初始化一些变量或者打印一些提示信息。
   - 比如在处理文件之前,先打印一行 "Processing the file..."。
2. END 模块:
   - `END` 模块是在 awk 处理完所有输入数据之后执行的。
   - 它通常用于输出一些最终的统计信息或者结果。
   - 比如在处理完文件后,打印出总共处理了多少行数据。



### awk运算符

| 运算符                  | 描述                                                         |
| ----------------------- | ------------------------------------------------------------ |
| **赋值运算符**          |                                                              |
| = += -= *= /= %= ^= **= | 赋值语句                                                     |
| **逻辑运算符**          |                                                              |
| \|\|                    | 逻辑或                                                       |
| &&                      | 逻辑与                                                       |
| **正则运算符**          |                                                              |
| ~ !~                    | 匹配正则表达式和不匹配正则表达式                             |
| **关系运算符**          |                                                              |
| < <= > >= != ==         | 关系运算符\> < 可以作为字符串比较，也可以用作数值比较，关键看操作数如果是字符串就会转换为字符串比较。两个都为数字 才转为数值比较。字符串比较：按照ascii码顺序比较。 |
| **算数运算符**          | 所有用作算术运算符进行操作，操作数自动转为数值，所有非数值都变为0 |
| + -                     | 加,减                                                        |
| * / &                   | 乘,除与求余                                                  |
| + - !                   | 一元加,减和逻辑非                                            |
| ^ ***                   | 求幂                                                         |
| ++ --                   | 增加或减少，作为前缀或后缀                                   |
| **其他运算符**          |                                                              |
| $                       | 字段引用                                                     |
| 空格                    | 字符串链接符                                                 |
| ?:                      | 三目运算符                                                   |
| ln                      | 数组中是否存在某键值                                         |



### awk正则

|     元字符      | 功能                                            | 示例                                 | 解释                                                         |
| :-------------: | :---------------------------------------------- | ------------------------------------ | ------------------------------------------------------------ |
|        ^        | 首航定位符                                      | /^root/                              | 匹配所有以root开头的行                                       |
|        $        | 行尾定位符                                      | /root$/                              | 匹配所有以root结尾的行                                       |
|        .        | 匹配任意单个字符                                | /r..t/                               | 匹配字母r,然后两个任意字符，再以t结尾的行                    |
|        *        | 匹配0个或多个前导字符(包括回车)                 | /a*ool/                              | 匹配0个或多个a之后紧跟着ool的行，比如ool，aaaaool等          |
|        +        | 匹配1个或多个前导字符                           | /a+b/                                | ab, aaab                                                     |
|        ?        | 匹配0个或1个前导字符                            | /a?b/                                | b，ab                                                        |
|       []        | 匹配指定字符组内的任意一个字符                  | /^[abc]/                             | 匹配以a或b或c开头的行                                        |
|       [^]       | 匹配不在指定字符组内任意一个字符                | /\^[\^abc]/                          | 匹配不以字母a或b或c开头的行                                  |
|       ()        | 子表达式组合                                    | /(rool)+/                            | 表示一个或多个rool组合，当有一些字符需要组合时，使用括号括起来 |
|        ¦        | 或者的意思                                      | /(root)\¦B/                          | 匹配root或者B的行                                            |
|        \        | 转义字符                                        | /a\/\//                              | 匹配a//                                                      |
|      ~,!~       | 匹配，不匹配的条件语句                          | $1~/root/                            | 匹配第一个字段包含字符root的所有记录                         |
| x{m}x{m,}x{m,n} | x重复m次x重复至少m次x重复至少m次，但是不超过n次 | /(root){3}//(root){3,}//(root){3,6}/ |                                                              |



### awk的if、循环、和数组

#### if 条件判断

awk 提供了非常好的类似于 C 语言的 if 语句

```bash
{
    if ($1=="foo"){
    if ($2=="foo"){
        print"uno"
    }else{
        print"one"
    }
  }elseif($1=="bar"){
    print "two"
  }else{
    print"three"
  }
}
```

还可以转换为：

```bash
{
　　if ( $0 !~ /matchme/ ) {
　　　　print $1 $3 $4
　　}
}
```



#### while 循环

awk 的 while 循环结构，它等同于相应的 C 语言 while 循环。 awk 还有"do...while"循环，它在代码块结尾处对条件求值，而不像标准 while 循环那样在开始处求值。

它类似于其它语言中的"repeat...until"循环。以下是一个示例：

do...while 示例：

```bash
{
    count=1 do {
        print "I get printed at least once no matter what"
    } while ( count !=1 )
}
```

与一般的 while 循环不同，由于在代码块之后对条件求值， "do...while"循环永远都至少执行一次。换句话说，当第一次遇到普通 while 循环时，如果条件为假，将永远不执行该循环



#### for 循环

awk 允许创建 for 循环，它就象 while 循环，也等同于 C 语言的 for 循环：

```bash
for ( initial assignment; comparison; increment ) {
    code block
}
```

以下是一个简短示例：

```bash
[root@localhost ~]# cat awk.txt
#!/bin/awk
BEGIN{for ( x=1; x<=4; x++ ) {
    print "iteration", x
}}
[root@localhost ~]# awk -f awk.txt
iteration 1
iteration 2
iteration 3
iteration 4
```



**break 和 continue**

如同 C 语言一样， awk 提供了 break 和 continue 语句。使用这些语句可以更好地控制 awk 的循环结构。

**break语句：**

```bash
[root@localhost ~]# cat awk.txt
#!/bin/awk
BEGIN{
x=1
while(1) {
    print "iteration",x
    if ( x==10 ){
        break
    }
    x++
}
}
[root@localhost ~]# awk -f awk.txt
iteration 1
iteration 2
iteration 3
iteration 4
iteration 5
iteration 6
iteration 7
iteration 8
iteration 9
iteration 10
```

**continue 语句：**

```bash
[root@localhost ~]# cat awk.txt
#!/bin/awk
BEGIN{
x=1
while (1) {
        if ( x==4 ) {
        x++
        continue
    }
    print "iteration", x
    if ( x>20 ) {
        break
    }
    x++
}
}
[root@localhost ~]# awk -f awk.txt
iteration 1
iteration 2
iteration 3
iteration 5
iteration 6
iteration 7
iteration 8
iteration 9
iteration 10
iteration 11
iteration 12
iteration 13
iteration 14
iteration 15
iteration 16
iteration 17
iteration 18
iteration 19
iteration 20
iteration 21
```



#### 数组

AWK 中的数组都是关联数组,数字索引也会转变为字符串索引

在awk中，数组叫关联数组，与我们在其它编程语言中的数组有很大的区别。关联数组，简单来说，类似于python语言中的dict、java语言中的map，其下标不再局限于数值型，而可以是字符串，即下标为key，value=array[key]。既然为key，那其下标也不再是有序的啦。

```shell
#!/bin/awk
BEGIN{
    cities[1]="beijing"
    cities[2]="shanghai"
    cities["three"]="guangzhou"
    for( c in cities) {
        print cities[c]
    }
    print cities[1]
    print cities["1"]
    print cities["three"]
}

awk -f awk.txt <filename>
```

用 awk 中查看服务器连接状态并汇总

```shell
[root@localhost ~]# netstat -an|awk '/^tcp/{++s[$NF]}END{for(a in s)print a,s[a]}'
LISTEN 4
ESTABLISHED 2
```



### 字符串函数

| **函数名**                           | **功能**                                    | **参数**                    | **示例**                          | **输出**              |
| ------------------------------------ | ------------------------------------------- | --------------------------- | --------------------------------- | --------------------- |
| asort(arr, [d [, how]])              | 使用 GAWK 值比较的一般规则排序 arr 中的内容 | arr, d, how                 | asort(arr)                        | -                     |
| asorti(arr, [d [, how]])             | 对数组的索引排序                            | arr, d, how                 | asorti(arr)                       | -                     |
| gsub(regexp, replacement [, target]) | 全局替换子串                                | regexp, replacement, target | gsub("World", "Jerry", str)       | Hello, Jerry          |
| index(str, sub)                      | 检测子串是否存在                            | str, sub                    | index(str, subs)                  | 5                     |
| length(str)                          | 返回字符串长度                              | str                         | length(str)                       | 16                    |
| match(str, regex)                    | 搜索与正则表达式匹配的子串                  | str, regex                  | match(str, subs)                  | 5                     |
| split(str, arr, regex)               | 分割字符串                                  | str, arr, regex             | split(str, arr, ",")              | One, Two, Three, Four |
| sprintf(format, expr-list)           | 按指定格式构造字符串                        | format, expr-list           | sprintf("%s", "Hello, World !!!") | Hello, World !!!      |
| strtonum(str)                        | 将字符串转换为数值                          | str                         | strtonum("123")                   | 123                   |
| sub(regex, sub, string)              | 执行一次子串替换                            | regex, sub, string          | sub("World", "Jerry", str)        | Hello, Jerry          |
| substr(str, start, l)                | 返回子串                                    | str, start, l               | substr(str, 1, 5)                 | Hello                 |
| tolower(str)                         | 将所有大写字母转换为小写字母                | str                         | tolower(str)                      | hello, world !!!      |
| toupper(str)                         | 将所有小写字母转换为大写字母                | str                         | toupper(str)                      | HELLO, WORLD !!!      |



## 七、练习题

1.3. 简答
    1）找出当前目录下包含127.0.0.1关键字的文件？
    2）删除/显示1.txt文件第3行到第10行的内容？
    3）使用awk取出/etc/passwd第一列数据也就是取出用户名。
    4）用命令行更改config.txt文件，把里面所有的“name”更改为“address”
    5）写出查询file.txt以abc结尾的行
    6）删除file.txt文件中的空行
    7）打印file.txt文件中的第10行
    8）删除/etc/fstab文件中所有以#开头的行的行首的# 号及#后面的所有空白字符；
    9）查找最后创建时间是3天前，后缀是*.log的文件并删除（三种方法）
    10）使用sed命令打印出文件的第一行到第三行
    11）在/var/sync/log/cef_watchd-20080424.1og文件中查找大小写不敏感“mysql"字符串中的命令是
    12）为了在/var/sync/log 目录中查找更改时间在5日以前的文件井删除它们，linux命令是
    13）把data目录及其子目录下所有以扩展名.txt结尾的文件中包含oldgirl的字符串全部替换为oldboy.
    14）写出删除abc.txt文件中的空行
    15）查看linux服务器ip的命令，同时只显示包含ip所在的行打印出来
    16）有文件file1
        请用shell查询file1里面空行的所在行号
        查询file1以abc结尾的行
        打印file文件第一行到第三行
        显示file文件里匹配foo字串那行以及上下5行、显示foo及前5行、显示foo及后5行
    17）当前系统中没有任何文本编辑器（vi,emacs,vim,edit等），如何过来掉注释行和空行查看/etc/ssh/sshd_config文件

18）例如：文件名为“filename”，文件内容如下：

```
 #This is a comments-1
    #This is a comments-2
    This is a comments-1
    This is a comments-2
    This is a comments-3
    This is a comments-4
```

​    查找file.log文件中的包含关键字“helloworld”的内容，及其上下两行的内容从定向保存到1.txt。请写出命令
​    echo "ABCDEF abtdefg" |sed -i s/c/t/g 这条命令是否正确？如若正确可能会显示什么样的结果？
​    查找文件中1到20行之间，同时将"aaa"替换为"AAA","ddd"替换"DDD"
​    用awk获取文件中第三行的倒数第二列字段

二. 进阶题目:
    需要用到awk数组和函数知识点

    1、利用sed命令将test.txt中所有的回车替换成空格？
    2、找出ifconfig命令结果中的1-255之间的数值；
    3、文件内容排序、文件行取唯一值的命令分别是？
    4、用awk获取文件中第三行的倒数第二列字段
    5、有一个文件nginx.log，请用awk提取时间（HH:MM）,文件内容如下：
    183.250.220.178|-l[20/jul/2017:10:35:14 +0800]|POST /audiosearch/search
    HTTP/1.1|200|54|-lDalvik/1.6.0（linux;U;Android 4,4,4;Konka Android TV 638
    Build/KTU84P）|-l-[5.069|5.001,0.005|www.kuyun.com|8771|172.21.19.67:8084,172.21.19.66:8084]
    183.250.220.178|-l[20/jul/2017:10:35:14 +0800]|POST /audiosearch/search
    HTTP/1.1|200|54|-lDalvik/1.6.0（linux;U;Android 4,4,4;Konka Android TV 638
    Build/KTU84P）|-l-[5.069|5.001,0.005|www.kuyun.com|8771|172.21.19.67:8084,172.21.19.66:8084]
    从a.log文件中提取包含“WARNING”或“FATAL”，同时不包含“IGNOR”行，然后，提取以“：”分割的第五个字段

三. 更进阶题目
    1、统计apache访问日志流量排名前10个IP
    2、统计出apache的access.log 中访问最多的5个ip
    3、这条linux命令的含义：netstat -n |awk '/^tcp/ {++h[$NF]} END {for(a in h ){print a,h[a]} }'
    4、使用awk分析日志（最后一个字段是IP，统计访问量前十的IP，并进行排序）
