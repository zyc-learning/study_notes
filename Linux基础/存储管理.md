# 存储和LVM逻辑卷管理

## 一、管理分区

- 列出块设备

```bash
[root@localhost ~]# lsblk
```

- 创建分区命令

```bash
fdisk  管理MBR分区
gdisk  管理GPT分区
parted 高级分区操作
```

- 重新设置内存中的内核分区表版本

```bash
partprobe
```



### parted 命令

**parted的操作都是实时生效的，小心使用**

- 格式：

```bash
parted [选项]... [设备 [命令 [参数]...]...]
```

操作

```
  -l, --list                      lists partition layout on all block devices
  -m, --machine                   displays machine parseable output
  -j, --json                      displays JSON output
  -s, --script                    never prompts for user intervention
  -f, --fix                       in script mode, fix instead of abort when asked
  -v, --version                   displays the version
  -a, --align=[none|cyl|min|opt]  alignment for new partitions

COMMANDs:
  align-check TYPE N                       check partition N for TYPE(min|opt)
        alignment
  help [COMMAND]                           print general help, or help on
        COMMAND
  mklabel,mktable LABEL-TYPE               create a new disklabel (partition
        table)
  mkpart PART-TYPE [FS-TYPE] START END     make a partition
  name NUMBER NAME                         name partition NUMBER as NAME
  print [devices|free|list,all]            display the partition table, or
        available devices, or free space, or all found partitions
  quit                                     exit program
  rescue START END                         rescue a lost partition near START
        and END
  resizepart NUMBER END                    resize partition NUMBER
  rm NUMBER                                delete partition NUMBER
  select DEVICE                            choose the device to edit
  disk_set FLAG STATE                      change the FLAG on selected device
  disk_toggle [FLAG]                       toggle the state of FLAG on selected
        device
  set NUMBER FLAG STATE                    change the FLAG on partition NUMBER
  toggle [NUMBER [FLAG]]                   toggle the state of FLAG on partition
        NUMBER
  type NUMBER TYPE-ID or TYPE-UUID         type set TYPE-ID or TYPE-UUID of
        partition NUMBER
  unit UNIT                                set the default unit to UNIT
  version                                  display the version number and
        copyright information of GNU Parted
```



- 查看分区情况

```bash
[root@localhost ~]# parted /dev/硬盘名 print
```



- 设置磁盘的分区表

```bash
[root@localhost ~]# parted /dev/硬盘名 mklabel msdos
[root@localhost ~]# parted /dev/硬盘名 mklabel gpt
```



- 对磁盘进行分区

```bash
[root@localhost ~]# parted /dev/硬盘名 mkpart 需要删除分区的信息
```



- 删除分区

```bash
[root@localhost ~]# parted /dev/硬盘名 rm 需要删除的分区号
```



- 修改磁盘为mbr分区，注意会丢失所有数据

```bash
[root@localhost ~]# parted /dev/硬盘名 mklabel msdos
```



### fdisk工具

管理磁盘分区

```
fdisk [磁盘名称]
```

fdisk命令中的参数以及作用(类似于vim)

| 参数 | 作用                   |
| ---- | ---------------------- |
| m    | 查看全部可用的参数     |
| n    | 添加新的分区           |
| d    | 删除某个分区信息       |
| l    | 列出所有可用的分区类型 |
| t    | 改变某个分区的类型     |
| p    | 查看分区信息           |
| w    | 保存并退出             |
| q    | 不保存直接退出         |



### gdisk工具

**RockyLinux 没有内置gdisk，需手动安装**

类fdisk 的GPT分区工具



## 二、存储结构与磁盘划分

### mkfs工具

- Linux mkfs（英文全拼：make file system）命令用于在特定的分区上建立 linux 文件系统。
- 格式：

```bash
mkfs [-V] [-t fstype] [fs-options] filesys [blocks]
```

- 选项：
  - device ： 预备检查的硬盘分区，例如：/dev/sda1
  - -V : 详细显示模式
  - -t : 给定档案系统的型式，Linux 的预设值为 ext2
  - -c : 在制做档案系统前，检查该partition 是否有坏轨
  - -l bad_blocks_file : 将有坏轨的block资料加到 bad_blocks_file 里面
  - block : 给定 block 的大小



### mount

挂载文件系统`mount 文件系统 挂载目录`

mount命令中的参数以及作用

| 参数 | 作用                                                         |
| ---- | ------------------------------------------------------------ |
| -a   | 挂载所有在/etc/fstab中定义的文件系统                         |
| -t   | 指定文件系统的类型                                           |
| -o   | 设置挂载选项，可以是多个选项，用逗号分隔，比如 *rw* 表示读写权限，*noatime*表示不更新文件的访问时间戳，*defaults* 表示使用默认选项等。 |
| -f   | 不执行挂载操作，通常与 -v一起使用来测试或调试挂载命令。      |
| -F   | 结合 -a使用时，对于每一个挂载动作产生一个子进程执行挂载，有助于加快大量挂载操作的速度。 |



永久挂载：把要挂载的分区写在/etc/fstab下，写完需要mount -a 检查是否写错，避免下次启动时打不开系统

| 字段     | 意义                                                         |
| -------- | ------------------------------------------------------------ |
| 设备文件 | 一般为设备的路径+设备名称，也可以写唯一识别码（UUID，Universally Unique Identifier） |
| 挂载目录 | 指定要挂载到的目录，需在挂载前创建好                         |
| 格式类型 | 指定文件系统的格式，比如Ext3、Ext4、XFS、SWAP、iso9660（此为光盘设备）等 |
| 权限选项 | 若设置为defaults，则默认权限为：rw, suid, dev, exec, auto, nouser, async |
| 是否备份 | 若为1则开机后使用dump进行磁盘备份，为0则不备份               |
| 是否自检 | 若为1则开机后自动进行磁盘自检，为0则不自检                   |



### umount

撤销已经挂载的设备文件`umount [挂载点/设备文件]`

```bash
[root@node-1 ~]# umount /dev/sda2
```



### df

用于显示文件系统的磁盘空间使用情况

```bash
df [选项]
```

常用选项

- `-h`：以人类可读的格式显示磁盘空间，使用K、M、G等单位。
- `-T`：显示文件系统类型。



### du

查看某个目录下文件数据的占用量

```bash
du [选项] [文件]
选项：
-a,--all: 显示目录中所有文件以及文件夹大小
-h: 以 Kb、Mb 、Gb 等易读的单位显示大小
--si: 类似 -h 选项，但是计算是用 1000 为基数而不是1024
-s，--summarize: 显示目录总大小(不能和"-a","-d"组合使用)
-d: 是 --max-depth=N 选项的简写，表示深入到第几层目录,超过指定层数目录则忽略
-c,--total: 除了显示目录大小外，额外一行显示总占用量
--time: 显示每一个目录下最近修改文件的时间
-t: 是 --threshold=SIZE 的简写，过滤掉小于 SIZE 大小的文件以及目录
--exclude=PATTERN：过滤与PATTERN匹配的文件名或者目录名

[root@localhost ~]# du -sh /etc
```



### 添加交换分区

SWAP（交换）分区是一种通过在硬盘中预先划分一定的空间，然后将把内存中暂时不常用的数据临时存放到硬盘中，以便腾出物理内存空间让更活跃的程序服务来使用的技术

```bash
[root@localhost ~]# swapon /dev/sdb2   #将后面指定的磁盘设为swap分区
[root@localhost ~]# swapoff /dev/sdb2   #关闭交换分区
-a：用于停用所有的交换空间。
-h：查看帮助信息。
-V：查看版本信息。
```



## 三、磁盘容量配额

### quota

作用：用于针对某个用户，限制使用空间

配额前需要先检查挂载点是否支持quota挂载（ext4支持配额）

重新挂载，让文件系统支持quota配置

```bash
[root@atopos ~]#  mount -o remount,usrquota,grpquota /mnt/mountpoint1/
[root@atopos ~]#  mount | grep mountpoint1
/dev/sdb1 on /mnt/mountpoint1 type ext4 (rw,relatime,seclabel,quota,usrquota,grpquota,data=ordered)
```

开启quota前需要先检查

```bash
[root@atopos ~]# quotacheck -avug
-a：扫描所有在/etc/mtab内含有quota参数的文件系统
-u：针对用户扫描文件与目录的使用情况，会新建一个aquota.user文件
-g：针对用户组扫描文件与目录的使用情况，会新增一个aquota.group文件
-v：显示扫描过程的信息
[root@atopos ~]# quotaon -avug #开启quota
```

Linux edquota命令的常用选项或参数说明
以下是edquota命令的一些常用选项和参数：

| 选项/参数 | 说明                             |
| --------- | -------------------------------- |
| -r        | 编辑远程配额（通过RPC）          |
| -u        | 编辑用户配额                     |
| -g        | 编辑组配额                       |
| -p        | 从原型用户/组复制数据            |
| -F        | 为指定的格式编辑配额             |
| -f        | 仅对给定的文件系统执行指定的操作 |
| -t        | 编辑每个文件系统的软时间限制     |
| -s        | 以人类可读的格式显示             |



### quotacheck

quotacheck的部分选项：

| 选项/参数 | 说明                                       |
| --------- | ------------------------------------------ |
| -a        | 检查所有在/etc/fstab中配置了配额的文件系统 |
| -u        | 检查用户配额                               |
| -g        | 检查组配额                                 |
| -m        | 不重新挂载文件系统                         |
| -v        | 显示详细的执行过程                         |
| -f        | 强制检查                                   |
| -b        | 在检查前备份旧的配额数据库文件             |
| -n        | 使用第一个配额条目                         |



### quotaon

quotaon部分选项：

| 选项/参数 | 说明                                       |
| --------- | ------------------------------------------ |
| -a        | 启用所有在/etc/fstab中配置了配额的文件系统 |
| -u        | 启用用户配额                               |
| -g        | 启用组配额                                 |
| -v        | 显示详细的执行过程                         |
| -p        | 显示配额的状态                             |



### quotaoff

quotaoff部分选项：

| 选项/参数 | 说明                                       |
| --------- | ------------------------------------------ |
| -a        | 禁用所有在/etc/fstab中配置了配额的文件系统 |
| -u        | 禁用用户配额                               |
| -g        | 禁用组配额                                 |
| -v        | 显示详细的执行过程                         |
| -p        | 显示详细的执行过程                         |



编辑配置配额

```bash
[root@atopos ~]# edquota -u user1
```

复制相同配额给其他用户

```bash
[root@atopos ~]# edquota -p user1 -u user2
```

查看限制情况

```bash
[root@atopos ~]# repquota -as
```



### xfs_quota

专门针对XFS文件系统来管理quota磁盘容量配额服务

```
xfs_quota [参数] 配额 文件系统
```

- -c参数用于以参数的形式设置要执行的命令
- -x参数是专家模式



## 四、软硬方式链接

硬链接：指向或者记录目标文件的inode和block

软链接：源文件的路径



### ln

用于创建链接文件

```bash
ln [选项] 源文件 目标文件
```

ln命令中可用的参数以及作用

| 参数 | 作用                                               |
| ---- | -------------------------------------------------- |
| -s   | 创建“符号链接”（如果不带-s参数，则默认创建硬链接） |
| -f   | 强制创建文件或目录的链接                           |
| -i   | 覆盖前先询问                                       |
| -v   | 显示创建链接的过程                                 |



## 五、磁盘阵列

使用磁盘阵列的原因：单块磁盘损坏时数据安全无法保障，单块磁盘效率低

优点：

缺点：不能动态的扩容和缩容



RAID 0（数据条带化）：读写性能*N，但是挂了一块盘会导致所有数据丢失。（性能最好）

RAID 1（数据镜像化）：读写性能*1，挂了一块盘有备份。

RAID 5（奇偶校验的条带化）：写性能*1，读性能\*（N-1）

RAID5的核心思想是使用奇偶校验信息来提供数据的冗余备份。当其中一个硬盘驱动器发生故障时，剩余的硬盘驱动器可以恢复丢失的数据。



RAID 10（镜像与条带化的组合）：先做数据镜像，再做数据条带

读写性能*N（N为RAID0的硬盘数，此例为2），不能同时坏数据块1a与2a(不能RAID1同一组合同时坏)



RAID 01（镜像与条带化的组合）：先做数据条带，再做数据镜像



### 磁盘阵列步骤

```shell
建立磁盘阵列
1.创建磁盘阵列
[root@localhost ~]# mdadm -Cv 创建列阵文件夹 -a yes -指定设备数量 -指定列阵方式 磁盘分区
2.格式化文件系统
[root@localhost ~]# mkfs.ext4 磁盘分区
3.挂载磁盘
[root@localhost ~]# mkdir 挂载点
[root@localhost ~]# mount 磁盘分区 挂载点
4.检查磁盘阵列信息
[root@localhost ~]# mdadm -D 磁盘分区

删除磁盘阵列
1.取消挂载，如果写入到fstab文件中，要记得删除
[root@localhost ~]# umount 磁盘分区 
2.停止磁盘整列
[root@localhost ~]# mdadm -S 磁盘分区
mdadm: stopped /dev/md0
3.删除阵列中的数据块信息
[root@localhost ~]# mdadm --zero-superblock /dev/nvme0n2 /dev/nvme0n3

# 通过fio磁盘测试工具来测试我们的磁盘阵列的读写情况
[root@localhost ~]# yum install -y fio

# 开始测试
[root@localhost test]# fio --name=write_test --filename=/mnt/test/testfile --size=1G --bs=1M --rw=write --direct=1 --numjobs=1
write_test: (g=0): rw=write, bs=(R) 1024KiB-1024KiB, (W) 1024KiB-1024KiB, (T) 1024KiB-1024KiB, i                                                                   oengine=psync, iodepth=1
fio-3.35
Starting 1 process
write_test: Laying out IO file (1 file / 1024MiB)

write_test: (groupid=0, jobs=1): err= 0: pid=29670: Thu Nov 14 16:51:32 2024
  write: IOPS=1404, BW=1405MiB/s (1473MB/s)(1024MiB/729msec); 0 zone resets
    clat (usec): min=570, max=2700, avg=694.62, stdev=136.39
     lat (usec): min=588, max=2709, avg=710.02, stdev=136.41
    clat percentiles (usec):
     |  1.00th=[  586],  5.00th=[  594], 10.00th=[  603], 20.00th=[  619],
     | 30.00th=[  635], 40.00th=[  652], 50.00th=[  668], 60.00th=[  693],
     | 70.00th=[  709], 80.00th=[  742], 90.00th=[  783], 95.00th=[  848],
     | 99.00th=[ 1057], 99.50th=[ 1450], 99.90th=[ 2409], 99.95th=[ 2704],
     | 99.99th=[ 2704]
   bw (  MiB/s): min= 1400, max= 1400, per=99.67%, avg=1400.00, stdev= 0.00, samples=1
   iops        : min= 1400, max= 1400, avg=1400.00, stdev= 0.00, samples=1
  lat (usec)   : 750=83.11%, 1000=15.53%
  lat (msec)   : 2=1.07%, 4=0.29%
  cpu          : usr=0.14%, sys=8.52%, ctx=1024, majf=0, minf=8
  IO depths    : 1=100.0%, 2=0.0%, 4=0.0%, 8=0.0%, 16=0.0%, 32=0.0%, >=64=0.0%
     submit    : 0=0.0%, 4=100.0%, 8=0.0%, 16=0.0%, 32=0.0%, 64=0.0%, >=64=0.0%
     complete  : 0=0.0%, 4=100.0%, 8=0.0%, 16=0.0%, 32=0.0%, 64=0.0%, >=64=0.0%
     issued rwts: total=0,1024,0,0 short=0,0,0,0 dropped=0,0,0,0
     latency   : target=0, window=0, percentile=100.00%, depth=1

Run status group 0 (all jobs):
  WRITE: bw=1405MiB/s (1473MB/s), 1405MiB/s-1405MiB/s (1473MB/s-1473MB/s), io=1024MiB (1074MB),                                                                    run=729-729msec

Disk stats (read/write):
  nvme0n4: ios=0/1793, merge=0/6, ticks=0/1173, in_queue=1173, util=86.50%
```



### mdadm命令

常用参数以及作用

| 参数 | 作用                       |
| ---- | -------------------------- |
| -a   | 检测设备名称               |
| -n   | 指定设备数量               |
| -l   | 指定RAID级别               |
| -C   | 创建                       |
| -v   | 显示过程                   |
| -f   | 模拟设备损坏               |
| -r   | 移除设备                   |
| -Q/D | 查看摘要信息/详细信息      |
| -R   | 替换 RAID 阵列中的设备     |
| -S   | 停止RAID磁盘阵列           |
| -x   | 备份盘数量                 |
| -A   | 组装一个已存在的 RAID 阵列 |

```bash
[root@localhost ~]# mdadm -Cv 创建列阵文件夹 -a yes -指定设备数量 -指定列阵方式 磁盘分区
```



### 损坏磁盘阵列及修复

在确认有一块物理硬盘设备出现损坏而不能继续正常使用后，应该使用mdadm命令将其移除，然后查看RAID磁盘阵列的状态，可以发现状态已经改变。



在RAID 10级别的磁盘阵列中，当RAID 1磁盘阵列中存在一个故障盘时并不影响RAID 10磁盘阵列的使用。当购买了新的硬盘设备后再使用mdadm命令来予以替换即可，在此期间我们可以在/RAID目录中正常地创建或删除文件。先重启系统，然后再把新的硬盘添加到RAID磁盘阵列中。

```bash
[root@localhost ~]# umount /mnt/RAID/
#有时候失败，告诉设备忙，-f参数都没用
#用fuser -v -n file /mnt/RAID/查看谁占用文件详细，包括进程号
#用fuser -v -n tcp 22命令查看tcp22号端口占用的进程与用户
#用fuser -mk /mnt/RAID/命令杀死所有占用该文件的进程
#先热移除sdb
[root@localhost ~]# mdadm /dev/md0 -r /dev/sdb
#再加上sdb
[root@localhost ~]# echo "/dev/md0        /mnt/RAID       ext4    defaults        0       0" >> /etc/fstab
[root@localhost ~]# mount -a
# 有时候重新加sdb没用，只能删了阵列重新组，数据会全丢失
#[root@localhost ~]# umount /mnt/RAID/
#[root@localhost ~]# mdadm -S /dev/md0
#[root@localhost ~]# mdadm -Cv /dev/md0 -a yes -n 4 -l 10 /dev/sdb /dev/sdc /dev/sdd /dev/sde
#[root@localhost ~]# mkfs.ext4 /dev/md0
```



### 磁盘阵列+备份盘

现在创建一个RAID 5磁盘阵列+备份盘。在下面的命令中，参数-n 3代表创建这个RAID 5磁盘阵列所需的硬盘数，参数-l 5代表RAID的级别，而参数-x 1则代表有一块备份盘。当查看/dev/md0（即RAID 5磁盘阵列的名称）磁盘阵列的时候就能看到有一块备份盘在等待中了。将部署好的RAID 5磁盘阵列格式化为ext4文件格式，然后挂载到目录上，之后就可以使用了。把硬盘设备/dev/sdb移出磁盘阵列，然后迅速查看/dev/md0磁盘阵列的状态：列阵中sdb不可用， sde由原来的spare顶上来变成spare-building

```bash
[root@localhost ~]# mdadm -Cv /dev/md0 -n 3 -l 5 -x 1 /dev/sdb /dev/sdc /dev/sdd /dev/sde # -x 1是备份盘有一个
```



## 六、LVM逻辑卷管理器

在逻辑上，把所有的硬盘组合起来统称PV，

使用LVM技术可以很方便地对分完盘的分区（存储空间）再次进行管理

### LVM 逻辑卷组成

PV物理卷 相当于物理硬盘，或分区，RAID                    最底层

VG卷组 把多个物理卷整合起来，形成一个卷组         

PE逻辑块（物理块） 最小的存储单元

LV 逻辑卷  由VG分出供用户使用



### 部署逻辑卷

常用的LVM部署命令

显示所有逻辑卷的信息：lvs

| 功能/命令 | 物理卷管理 | 卷组管理  | 逻辑卷管理 |
| --------- | ---------- | --------- | ---------- |
| 扫描      | pvscan     | vgscan    | lvscan     |
| 建立      | pvcreate   | vgcreate  | lvcreate   |
| 显示      | pvdisplay  | vgdisplay | lvdisplay  |
| 删除      | pvremove   | vgremove  | lvremove   |
| 扩展      |            | vgextend  | lvextend   |
| 缩小      |            | vgreduce  | lvreduce   |



```
PV:
pvcreate 将物理磁盘/分区初始化为 LVM 物理卷。
-f 强制创建，覆盖现有签名
-u 指定 UUID

pvdisplay 显示物理卷详细信息
-m 显示物理卷的物理区域（PE）映射
-C：紧凑模式输出

pvs 简要列出所有物理卷信息
--noheadings：不显示标题行。
--units g：以 GB 为单位显示容量。

pvscan 扫描系统中所有物理卷

pvchange 修改物理卷属性
-u：生成新 UUID。
-x：启用/禁用分配（-x y 或 -x n）

pvmove 将物理卷上的数据迁移到其他物理卷
-n <lv>：指定迁移的逻辑卷

pvremove 删除物理卷的 LVM 元数据

VG:
vgcreate 创建卷组
-s <size>：设置物理扩展块（PE）大小

vgdisplay 显示卷组详细信息
-v：显示详细信息（包括逻辑卷和物理卷）

vgs 简要列出卷组信息
-o +vg_free：显示剩余空间

vgscan  扫描所有卷组

vgextend 向卷组中添加物理卷

vgreduce 从卷组中移除物理卷

vgchange  修改卷组属性
-a y|n：激活/停用卷组。

vgremove  删除卷组

vgrename  重命名卷组

LV:
lvcreate  创建逻辑卷
-L <size>：指定大小（如 10G）。
-l <pe_num>：指定 PE 数量（如 100%FREE 使用全部剩余空间）。
-n <name>：指定逻辑卷名称。
-i <stripes>：条带化数量（结合 -I 指定条带大小）

lvdisplay 显示逻辑卷详细信息

lvs 简要列出逻辑卷信息。
-o +devices：显示逻辑卷所在物理设备

lvscan  扫描所有逻辑卷

lvextend 扩展逻辑卷容量。
-r:自动调整文件系统大小（依赖文件系统类型如ext4，xfs等）
-L +5G：增加5G空间

lvreduce  缩小逻辑卷容量
-L 15G: 缩小逻辑卷容量

lvresize  调整逻辑卷大小
-L <要调整的大小>：扩大或缩小逻辑卷

lvchange  修改逻辑卷属性。
-p rw|ro：设置读写/只读权限。

lvremove  删除逻辑卷

lvrename  重命名逻辑卷
```



第1步：让新添加的两块硬盘设备支持LVM技术

```bash
[root@localhost ~]# pvcreate /dev/sdb /dev/sdc
#有时候创建不成功，有残留数据需要重新做分区表
[root@localhost ~]#parted /dev/sd[b-c] mklabel msdos
```

第2步：把两块硬盘设备加入到storage卷组中，然后查看卷组的状态

```bash
[root@localhost ~]# vgcreate storage /dev/sdb /dev/sdc
[root@localhost ~]# vgdisplay storage
```

第3步：切割出一个约为150MB的逻辑卷设备。

这里需要注意切割单位的问题。在对逻辑卷进行切割时有两种计量单位。

第一种是以容量为单位，所使用的参数为-L，后面直接跟要设置的大小。

另外一种是以基本单元的个数为单位，所使用的参数为-l。每个基本单元的大小默认为4MB。

```bash
# [root@localhost ~]# lvcreate -n vo -l 37 -I 8M storage
[root@localhost ~]# lvcreate -n vo -l 37 storage
```

第4步：把生成好的逻辑卷进行格式化，然后挂载使用。

```shell
[root@localhost ~]# mkfs.ext4 /dev/storage/vo
[root@localhost ~]# mkdir /mnt/vo
[root@localhost ~]# mount /dev/storage/vo /mnt/vo
```



### 扩容逻辑卷

第1步：把逻辑卷vo扩展至290MB

```bash
[root@localhost ~]# umount /mnt/vo  #需要先取消挂载
[root@localhost ~]# lvextend -L 290M /dev/storage/vo 
```

第2步：检查硬盘完整性，并重置硬盘容量，否则挂载了还是原本的大小

```bash
[root@localhost ~]# e2fsck -f /dev/storage/vo
e2fsck 
语法格式
e2fsck [选项] 设备
参数说明
-f：强制e2fsck在检查文件系统时自动修复错误，而不需要用户确认。
-y：在检查文件系统时自动应答"yes"，以便e2fsck自动修复检测到的错误。
-n：不实际修复错误，仅显示文件系统中检测到的错误。
-p：自动修复文件系统中的错误，而不需要用户确认。
-c：检查文件系统中的坏块，并将其标记为已损坏。
-D：优化文件系统，重新组织数据块和索引节点，以提高性能。
[root@localhost ~]# resize2fs /dev/storage/vo
```

第3步：重新挂载硬盘设备并查看挂载状态

```bash
[root@localhost ~]# mount -a
```

第4步，如果扩容超过第一块磁盘，则会依次占用到后面盘的pv

```shell
[root@localhost ~]# umount /mnt/vo
[root@localhost ~]# lvextend -L 30G /dev/storage/vo 
[root@localhost ~]# e2fsck -f /dev/storage/vo
[root@localhost ~]# resize2fs /dev/storage/vo
[root@localhost ~]# mount -a
```



### 缩小逻辑卷

第1步：检查文件系统的完整性

```bash
[root@localhost ~]# umount /mnt/vo 
[root@localhost ~]# e2fsck -f /dev/storage/vo
```

第2步：把逻辑卷vo的容量减小到120MB

```bash
[root@localhost ~]# resize2fs /dev/storage/vo 120M
[root@localhost ~]# lvreduce -L 120M /dev/storage/vo
```

第3步：重新挂载文件系统并查看系统状态

```bash
[root@localhost ~]# mount -a
```



### 逻辑卷快照

LVM还具备有“快照卷”功能，该功能类似于虚拟机软件的还原时间点功能。如果日后发现数据被改错了，就可以利用之前做好的快照卷进行覆盖还原。LVM的快照卷功能有两个特点：

**快照卷的容量必须等同于逻辑卷的容量**；

**快照卷仅一次有效，一旦执行还原操作后则会被立即自动删除。**

第1步：使用-s参数生成一个快照卷，使用-L参数指定切割的大小。

另外，还需要在命令后面写上是针对哪个逻辑卷执行的快照操作。**快照大小要和原来的LVM一样大**

```bash
[root@localhost ~]# lvcreate -L 120M -s -n SNAP /dev/storage/vo
#强烈建议快照大小和原来的LVM一样大，虽然指定大小是120M，并不是创建一个120M大小的快照，除非修改、新增的文件超出120M才会出事情，删除不影响。
```

第2步：在逻辑卷所挂载的目录中创建一个100MB的垃圾文件，然后再查看快照卷的状态。可以发现存储空间占的用量上升了

```bash
[root@localhost ~]# dd if=/dev/zero of=/mnt/vo/files count=1 bs=100M    #测试
```

第3步：为了校验SNAP快照卷的效果，需要对逻辑卷进行快照还原操作。在此之前记得先卸载掉逻辑卷设备与目录的挂载。

```bash
[root@localhost ~]# umount /mnt/vo
[root@localhost ~]# lvconvert --merge /dev/storage/SNAP 
```

第4步：快照卷会被自动删除掉，并且刚刚在逻辑卷设备被执行快照操作后再创建出来的100MB的垃圾文件也被清除了

```bash
[root@localhost ~]# mount -a
```



如果修改的文件超过120M，则不可能还原快照成功

```shell
[root@Centos7-VM-1 ~]# lvcreate -L 120M -s -n SNAP /dev/storage/vo
  Logical volume "SNAP" created.
[root@Centos7-VM-1 ~]# dd if=/dev/zero of=/mnt/vo/files count=2 bs=128M
[root@Centos7-VM-1 ~]# umount /mnt/vo
[root@Centos7-VM-1 ~]# lvconvert --merge /dev/storage/SNAP
  Unable to merge invalidated snapshot LV storage/SNAP.   #此处可看出来快照无法恢复
[root@Centos7-VM-1 ~]# lvremove /dev/storage/SNAP #用于删除快照
```



### 删除逻辑卷

第1步：取消逻辑卷与目录的挂载关联，删除配置文件中永久生效的设备参数。

```bash
[root@localhost ~]# umount /mnt/vo/
[root@localhost ~]# vim /etc/fstab    #删除配置文件中永久生效的设备参数
```

第2步：删除逻辑卷设备，需要输入y来确认操作

```bash
[root@localhost ~]# lvremove /dev/storage/vo 
```

第3步：删除卷组，此处只写卷组名称即可，不需要设备的绝对路径。

```bash
[root@localhost ~]# vgremove storage
```

第4步：删除物理卷设备

```bash
[root@localhost ~]# pvremove /dev/sdb /dev/sdc
```



步骤：

1. 让物理硬盘支持lvm技术 pvcreate 硬盘1 硬盘2
2. 创建卷组vg，并且将支持lvm技术的硬盘加到卷组中 vgcreate 硬盘1 .。。
3. 创建逻辑卷 lvcreate 
4. 格式化文件系统，挂载