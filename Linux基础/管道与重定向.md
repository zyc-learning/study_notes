#  管道与重定向

## 一、 重定向

### File Descriptors(FD，文件描述符 )

```bash
[root@192 fd]# ps aux | grep vim   #查找进程的进程号
root      16350  0.0  0.2 149432  5064 pts/1    S+   23:01   0:00 vim file1.txt
root      16360  0.0  0.0 112724   984 pts/0    S+   23:03   0:00 grep --color=auto vim
[root@192 fd]# cd /proc/16350/fd  #通过进程号打开进程的FD文件夹
[root@192 fd]# ll
总用量 0
lrwx------. 1 root root 64 6月   1 23:01 0 -> /dev/pts/1
lrwx------. 1 root root 64 6月   1 23:01 1 -> /dev/pts/1
lrwx------. 1 root root 64 6月   1 23:01 2 -> /dev/pts/1
lrwx------. 1 root root 64 6月   1 23:01 3 -> /root/.file1.txt.swp

# 这里有0 1 2 3
其中0表示标准输入
1表示标准正确输出
2表示标准错误输出
其他的都为输出到文件中
```



| Number | Channel name | Description | Default connection | Usage        |
| ------ | ------------ | ----------- | ------------------ | ------------ |
| 0      | stdin        | 标准输入    | 键盘               | 只读         |
| 1      | stdout       | 标准输出    | 命令行             | 只写         |
| 2      | stderr       | 标准错误    | 命令行             | 只写         |
| 3+     | filename     | 其他文件    | none               | 读 and/or 写 |



**到底什么是文件描述符呢？**

文件描述符是操作系统内部用于管理和跟踪打开的文件和I/O资源。比如当我们打开一个文件的时候，操作系统会分配一个文件描述符给这个文件，我们可以通过这个文件描述符来对文件进行读写等操作。

每个进程默认打开三个文件描述符：

- `0`：标准输入（stdin）
- `1`：标准输出（stdout）
- `2`：标准错误输出（stderr）



### 输出重定向(覆盖,追加)

```bash
[1(2)]>(>>)   /  <(<<):覆盖（追加）输出正确（默认）或出错信息   /  覆盖（追加）输入正确（默认）或出错信息
```

**示例一：输出重定向(覆盖)**

```bash
[root@localhost ~]# date 1> date.txt
[root@localhost ~]# cat date.txt
```

**示例二：输出重定向(追加)**

```bash
[root@localhost ~]# date >> date.txt
[root@localhost ~]# date >> date.txt
[root@localhost ~]# date >> date.txt
[root@localhost ~]# cat date.txt
```

**示例三：错误输出重定向**

```bash
[root@localhost ~]# touch file
[root@localhost ~]# cd file
bash: cd: file: 不是目录
[root@localhost ~]# cd file 2> log.txt
[root@localhost ~]# cat log.txt
bash: cd: file: 不是目录
```

**示例四：正确和错误都输入到相同位置**

```bash
[root@localhost ~]# ls /home/ /test
ls: 无法访问/test: 没有那个文件或目录
/home/:
user01

#将正确和错误的输出都输出的文件中
[root@localhost ~]# ls /home/ /test &> log.txt
[root@localhost ~]# cat log.txt
ls: 无法访问/test: 没有那个文件或目录
/home/:
user01
```

**示例五：正确和错误都输入到相同位置**

```bash
[root@localhost ~]# ls /home/ /test > log.txt
ls: 无法访问/test: 没有那个文件或目录
[root@localhost ~]# ls /home/ /test > log.txt 2>&1
[root@localhost ~]# cat log.txt
ls: 无法访问/test: 没有那个文件或目录
/home/:
user01
```

**示例六：重定向到空设备`/dev/null`**

```bash
# /dev/null是一个空设备，可以理解为一个无限大的垃圾堆，可以往里面丢任意多的垃圾进去

[root@localhost ~]# ls /home/ /test > log.txt 2>/dev/null
[root@localhost ~]# cat log.txt
/home/:
user01

[root@localhost ~]# ls /home/ /test &>/dev/null
```

**实例七：正确和错误输出到不同位置**

```bash
[root@localhost ~]# ls /home 1> right.txt /test 2> error.txt
[root@localhost ~]# cat test.txt
/home/:
[root@localhost ~]# cat error.txt
ls: cannot access '/test': No such file or directory
```



### 输入重定向

标准输入：`< 等价 0<`

**案例1：**

```bash
[root@localhost ~]# cat < /etc/passwd
```

**例2：**

```bash
[root@localhost ~]# grep 'root' < /etc/passwd
root:x:0:0:root:/root:/bin/bash
operator:x:11:0:operator:/root:/sbin/nologin
```

**案例3：at**

```bash
[root@localhost ~]# at now +5 min
at> ping -c4 baidu.com
at> <EOT>
job 1 at Thu Dec 12 15:50:00 2019
[root@localhost ~]# vim at.txt
ping -c4 baidu.com
[root@localhost ~]# at now +1 min < at.txt 
job 2 at Thu Dec 12 15:47:00 2019
```

**案例4：**利用重定向建立多行的文件

```bash
[root@localhost ~]# cat > file2.txt <<EOF
> hello
> python
> linux
> EOF
[root@localhost ~]# cat file2.txt
hello
python
linux
```



## 二、进程管道

管道是把前一项的输出导出，作为后一项的输入

用法：`command1 | command2 | command3 | ....`

tee管道

在普通管道的情况下，一个管道指向终端或者文件
