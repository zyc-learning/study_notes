# 远程管理、FTP和NFS

## 一、远程管理(SSH)

ssh是目前较可靠，专为远程登录会话和其他网络服务提供安全性的协议

有效防止远程管理过程中的信息泄漏；传输**数据加密**，能够防止DNS和IP欺骗；传输**数据压缩**，加快传输速度

### 一、ssh协议

#### ssh客户端使用

```shell
[root@node1 ~]# ssh root@192.168.175.147  # 登录远程ssh主机
[root@node1 ~]# ssh -p22 root@192.168.175.147  # 指定端口号登录远程主机
[root@node1 ~]# ssh -p22 root@192.168.175.147 ls -lha /etc   # 让远程主机执行指定命令
```

查看已经连接过主机的记录(会看到ssh客户端产生的公钥信息)

```bash
[root@localhost ~]# cat .ssh/known_hosts
192.168.88.20 ssh-ed25519 AAAAC3NzaC1lZDI1NTE5AAAAIOThT7fdh7wxANOIlTBGdcF+m2sVH/N56HKSJGANz19u
192.168.88.20 ssh-rsa AAAAB3NzaC1yc2EAAAADAQABAAABgQCmVQz5ziwIu9Ue3tUT2BGSr81+t7E3dpJBGuydoBnVeD6S7PVVkyf8RxsbYd1D0PhxlIb5qJzxybla8ua47J1RqKEZjNA0CITV4oFCcdTt38hqZzE1JxNqcV3TyqPt0uFetB09bYckk2T/HascnKAm2G7Sl+BIbs27oeFPhkSph/wfOLxh9nn6Yk3NwqPXrpUmn7w4A8P8UdeSXD4YvK/TNjPz9/eI0a2joxNpzyS0glcBhWfEb2UiplDGJlKoVl0NPxYhhYcwDLtzNhfgmre2wcgA9v3phdTUvsH1QWExE4qhpIisNa7jUhrB8Gg6ki3sI143MJnvdD56BILbv2U7UPOjIR5bTRx2yuDp2Z3d5lK+8gowyXAjmp59gVfUO8vaLVZ5oBiuzPBBntWqBrfYfWmd2CqoYFHXjCf+6quPNx2hVASIfHvUWXQuYzo8NOgaR0niMzzanADam3B87Tqlvo9psUQ1TQ1zdJlvo8FL+TkYyn6+Bc5lGJ3/un4Ip6s=
```

通过scp来远程管理文件

```shell
[root@node1 ~]# scp -P22 -r -p /root/file root@192.168.175.147:/tmp
# 将本地文件复制给远程主机，-r递归复制整个目录，-p保留源文件的时间和权限属性
[root@node1 ~]# scp -P22 -r -p root@192.168.175.147:/tmp/file /root/
# 将远程主机的文件复制到本地
scp 传走文件 目标文件
```

ssh自带的sftp功能

```shell
[root@node1 ~]# sftp -oPort=22 root@192.168.175.147
root@192.168.175.147's password: 
Connected to 192.168.175.147.
sftp> put /etc/hosts /tmp  
sftp> get /etc/hosts /root
# 使用sftp在两台主机之前互相传递文件
```



#### sshd配置文件

- sshd服务的配置信息保存在`/etc/ssh/sshd_config`文件中。配置文件中有许多以井号开头的注释行，要想让这些配置参数生效，需要在修改参数后再去掉前面的井号

| 参数                              | 作用                                |
| :-------------------------------- | :---------------------------------- |
| Port 22                           | 默认的sshd服务端口                  |
| ListenAddress 0.0.0.0             | 设定sshd服务器监听的IP地址          |
| Protocol 2                        | SSH协议的版本号                     |
| HostKey /etc/ssh/ssh_host_key     | SSH协议版本为1时，DES私钥存放的位置 |
| HostKey /etc/ssh/ssh_host_rsa_key | SSH协议版本为2时，RSA私钥存放的位置 |
| HostKey /etc/ssh/ssh_host_dsa_key | SSH协议版本为2时，DSA私钥存放的位置 |
| PermitRootLogin yes               | 设定是否允许root管理员直接登录      |
| StrictModes yes                   | 当远程用户的私钥改变时直接拒绝连接  |
| MaxAuthTries 6                    | 最大密码尝试次数                    |
| MaxSessions 10                    | 最大终端数                          |
| PasswordAuthentication yes        | 是否允许密码验证                    |
| PermitEmptyPasswords no           | 是否允许空密码登录（很不安全）      |



### 二、安全密钥验证

非对称加密

1. **密钥生成**：首先生成一对密钥，一个公钥和一个私钥。
2. **加密**：发送方使用接收方的公钥来加密信息。这个过程是可逆的，但只有拥有正确私钥的人才能解密。
3. **解密**：接收方使用自己的私钥来解密信息。这个过程确保了只有拥有私钥的接收方才能阅读信息。



我们可以想象一下，你有一个非常特别的邮箱，这个邮箱有一个特点：它有两个锁。一个锁是公开的，任何人都可以往里投信，但只有你知道如何打开它（私钥）。另一个锁是私有的，只有你知道它在哪里，而且只有你拥有打开它的钥匙（公钥）。

- **公钥（锁）**：你把这个特别的锁（公钥）放在一个公共的地方，比如你的家门口。任何人都可以给你写信，他们只需要用这个锁把你的信锁起来，然后投进你的邮箱。因为只有你知道如何打开这个锁，所以你的信件在运输过程中是安全的。
- **私钥（钥匙）**：你把打开这个锁的钥匙（私钥）藏在家里一个安全的地方。当信件到达时，你可以用你的私钥打开锁，取出信件阅读。
- **安全性**：即使有人试图复制这个锁（公钥），他们也无法制造出能打开它的钥匙（私钥），因为这两个是数学上相关的，但计算其中一个从另一个是几乎不可能的。



#### SSH密钥对口令验证

1.在客户端主机中生成“密钥对”

```shell
[root@localhost ~]# ssh-keygen
# 查看/root/.ssh目录中，是否存在id_rsa(私钥)和id_rsa.pub(公钥)
[root@localhost ~]# ls -al /root/.ssh/
```

2.把客户端主机中生成的公钥文件传送至远程主机

```shell
[root@localhost ~]# ssh-copy-id 192.168.91.128
# 检查server2中，是否成功接收到公钥
# server2中查看
[root@localhost ~]# ls -al /root/.ssh/
# 公钥发送过来以后，名称会默认的改变为authorized_keys。我们可以查看这个文件中的内容，就是我们的公钥，与id_rsa.pub一致
[root@localhost ~]# cat /root/.ssh/authorized_keys
ssh-rsa AAAAB3NzaC1yc2EAAAADAQABAAABgQDpPlj0cTuje/LHClQ+InIzTSdC2AViBWD3hb77ZcFpC1rfem7A9fuOJEZlNNALeHyAVjVvlVujhWDO8e7mbSJ0k/ECUVvq82r5bf9g8nJKuyWmKQ8DWHXhe4+WnMKHRDPsDM7blr/tnaUb86FPql0MUW1VOEQkP3ZN+NDomfH2DAuMzX5EKhYkcvVuekELeevXlEwWHA/mmizkxBqFKuoBdSpiQ7xjVC+FxAjAnrQwD1jmdrf+25x8DYm9J2S+led6fy3s6QPYRlawAR91M2Xf8+W1RHndcnZGhReCtZBJsIs6OCC3NqxCeZIVgwZzeAtPClWDyh1YhuvEL5mM1hjHICWhHCLqo15R7A0e/zCqhf3wxfelnQ21aNAbzALDYAjkquxm7nLbmRq07Na0XdASfJHpiuDG/aYzNTWaiQzcgZQmz13FUNfI+dikRupwL3XW57eNfo3qHNhZn9TxIQOueJ6N7vbSoYdiN34xvc8g1ZRPRFONftMg1HYBcZAYgMk= root@localhost.localdomain
```

3.对远程主机进行设置，使其只允许密钥验证，拒绝传统的口令验证方式。

```shell
[root@localhost ~]# vim /etc/ssh/sshd_config
..................
PasswordAuthentication no
PubkeyAuthentication yes
...................
[root@localhost ~]# systemctl restart sshd
```

4.在客户端尝试登录到服务器，此时无须输入密码也可成功登录

```shell
[root@localhost ~]# ssh 192.168.91.128
# 并且检查server2中的secure日志中，也可以看到我们是通过公钥登录到server2中
[root@localhost ~]# cat /var/log/secure |grep publickey
Dec 25 09:40:27 localhost sshd[2392]: Accepted publickey for root from 192.168.88.10 port 40652 ssh2: RSA SHA256:+LY6jvJ6Azxw9avB5eMKOMBrzvryMVG1nHjszJI22lk
```



### 三、mobaxterm使用密钥登录

1、生成密钥

点击 "工具--网络--mobaKeyGen" 

2、分别保存公私钥对

按顺序点击“generate”   "save public key"  "save private key"

**注：在生成密钥时，需要鼠标滑动，因为密钥是根据鼠标轨迹生成的**

3、linux .ssh目录下新建文件,将上面生成的密钥粘进去

```shell
[root@localhost ~]# vim .ssh/authorized_keys
```



## 二、FTP

FTP：远程计算机系统和本地计算机系统之间传输文件的一个标准

**应用场景：下载服务器偏多，文件持久化存储**

FTP模型

用户接口：提供一个用户接口并使用客户端协议解释器的服务

客户端协议解释器：向远程服务器发送命令 并建立客户数据传输过程

服务端协议解释器：响应客户协议机发出的命令并驱动服务端数据传输过程

客户端数据传输协议：负责完成和服务器数据传输过程及客户端本地文件系统的通信

服务端数据传输协议：负责完成和客户数据过程及服务器端文件系统的通信



控制连接（端口号21）

FTP 的控制连接使用端口 21。这条连接用于客户端与服务器之间交换命令和响应。当你在 FTP 客户端中输入命令（例如 `LIST`、`RETR`、`STOR`）时，这些命令是通过端口 21 发送的。

**数据流向**：控制连接是全双工的，客户端和服务器都可以发送消息，但所有数据传输操作（如文件上传、下载）都不会通过控制连接进行。

数据连接（端口号20）

端口 20 在 FTP 协议中用于数据传输连接，特别是在 **主动模式**（PORT 模式）下。它用于通过数据连接传输实际的文件数据。

**数据流向**：当 FTP 客户端在主动模式下与服务器建立连接时，服务器通过端口 20 向客户端的指定端口发起数据连接。这条连接用于传输文件内容。



### 工作原理

主动模式
1.建立控制连接：客户端发起建立控制连接，与服务器的21端口进行连接。
2.客户端执行命令：通过控制连接去执行
3.当客户端想要下载一个文件时：客户端先找到一个自己随机端口，把端口号告诉服务器
4.服务端收到了客户端的请求和端口号，通过自己的20端口主动向客户端的端口建立数据连接，并且传输数据

通过三次握手，建立控制连接；客户端的源端口是高位随机端口，目标端口是21端口，控制连接建立后，客户端进行身份验证，协商数据连接采用主动模式；随后客户端会向FTP服务器发送Port报文，表明自己监听的IP+端口，并等待FTP服务器（20端口）向自己监听的IP+端口发起数据连接请求。服务端发起数据连接请求，建立数据连接

**优点**：服务器主动发起数据连接，因此客户端无需配置其防火墙以允许入站连接。

**缺点**：如果客户端位于 NAT 或防火墙后面，客户端很难接受来自服务器的入站连接。由于 NAT 会改变客户端的 IP 地址和端口，服务器可能无法正确连接到客户端。



被动模式

1.建立控制连接：客户端发起建立控制连接，与服务器的21端口进行连接。
2.客户端执行命令：通过控制连接去执行
3.当客户端想要下载一个文件时：客户端提出使用被动模式PASV，服务端收到并回复连接信息。客户端收到后使用一个随机端口向服务器端口进行数据连接

通过三次握手，建立控制连接；客户端的源端口是高位随机端口，目标端口是21端口；控制连接建立后，客户端进行身份验证，协商数据连接采用被动模式；随后客户端会向服务器发送PASV报文，表示我们用被动模式。服务端收到PASV报文，于是向客户端发送Port报文，表明自己监听的IP+端口，客户端发起数据连接请求，建立数据连接

**优点：**被动模式解决了客户端处于 NAT 或防火墙后面时的问题，因为客户端只需要发起对服务器的外向连接，不需要接受来自服务器的入站连接。

**缺点：**服务器需要预先开放一个端口范围，并且在某些情况下，如果服务器的防火墙配置不当，仍然可能会遇到问题。



| 参数                        | 作用                                             |
| :-------------------------- | :----------------------------------------------- |
| listen=NO                   | 是否以独立运行的方式监听服务                     |
| listen_address=ip地址       | 设置要监听的IP地址                               |
| listen_port=21              | 设置FTP服务的监听端口                            |
| download_enable=YES         | 是否允许下载文件                                 |
| userlist_enable=YES         | 设置用户列表为"允许"                             |
| userlist_deny=YES           | 设置用户列表为"禁止"                             |
| max_clients=0               | 最大客户端连接数，0为不限制                      |
| max_per_ip=0                | 同一IP地址的最大连接数，0为不限制                |
| anonymous_enable=YES        | 是否允许匿名用户访问                             |
| anon_upload_enable=YES      | 是否允许匿名用户上传文件                         |
| anon_umask                  | 匿名用户上传文件的umask                          |
| anon_root=/var/ftp          | 匿名用户的ftp根目录                              |
| anon_mkdir_write_enable=YES | 是否允许匿名用户创建目录                         |
| anon_other_write_enable=YES | 是否开放匿名用户的其他写入权限（重命名、删除等） |
| anon_max_rate=0             | 匿名用户的最大传输速率，0为不限制                |
| local_enable=yes            | 是否允许本地用户登录                             |
| local_umask=022             | 本地用户上传文件的umask值                        |
| local_root=/vat/ftp         | 本地用户的ftp根目录                              |
| chroot_local_user=YES       | 是否将用户权限禁锢在ftp目录，以确保安全          |
| local_max_rate=0            | 本地用户的最大传输速率，0为不限制                |



### FTP常用服务软件

许多操作系统和第三方软件都提供 FTP 服务的实现。常见的 FTP 服务器软件有：

- **vsftpd**（Very Secure FTP Daemon）：在 Linux 上广泛使用的高安全性 FTP 服务器。
- **ProFTPD**：功能丰富的 FTP 服务，支持多种认证机制。
- **Pure-FTPd**：简单易用的 FTP 服务器，适用于 Unix/Linux 系统。
- **FileZilla Server**：在 Windows 上使用的开源 FTP 服务器。



### vsftpd介绍

- 软件包：vsftpd
- 服务类型：由Systemd启动的守护进程
- 配置单元：`/usr/lib/systemd/system/vsftpd.service`
- 守护进程：`/usr/sbin/vsftpd`
- 端口：`21(ftp)`,`20(ftp‐data)`
- 主配置文件：`/etc/vsftpd/vsftpd.conf`
- 用户访问控制配置文件：`/etc/vsftpd/ftpusers /etc/vsftpd/user_list`
- 日志文件：`/etc/logrotate.d/vsftpd`



### 基础配置

- 安装vsftpd并设置不允许登录的用户

```shell
[root@localhost ~]#yum -y install vsftpd
[root@localhost ~]#useradd -s/sbin/nologin vsftp
```

- 准备分发的文件

```shell
[root@localhost ~]#touch /var/ftp/abc.txt   #在/var/ftp文件夹下因为这是指定用于进行ftp服务的文件夹
```

- 配置文件中开启匿名用户登录

```bash
[root@localhost ~]# vim /etc/vsftpd/vsftpd.conf
......
anonymous_enable=YES
......
```

- 启动服务

```shell
[root@localhost ~]#systemctl start vsftpd
[root@localhost ~]#systemctl enable vsftpd
```

- 关闭防火墙

```shell
[root@localhost ~]#systemctl stop firewalld
[root@localhost ~]#setenforce 0
```



#### 命令

```bash
1.登录FTP服务器
方法一：直接输入ftp加ip地址ftp 192.168.10.xxx
方法二：直接输入ftp，进入ftp服务后输入open加ip地址open 192.168.10.xxx
当连接成功后会让你进行身份验证，在输入密码时屏幕上没有任何显示，不用管，直接输完密码敲回车键即可。

2.查看FTP服务器上的文件
（一般情况下用户都会被限制目录的访问权限，只可在当前目录下进行操作）
dir：显示服务器目录和文件列表
ls：显示服务器简易的文件列表
cd：进入服务器指定的目录

dir命令可以使用通配符“”和“?”，比如，显示当前目录中所有扩展名为jpg的文件，可使用命令 dir .jpg。
cd命令中必须带目录名。比如 cd main 表示进入当前目录下的main子目录

3.下载文件
上传和下载文件时应该使用正确的传输类型，FTP的传输类型分为ASCII码方式和二进制方式两种，对.txt、.htm等文件应采用ASCII码方式传输，对.exe或图片、视频、音频等文件应采用二进制方式传输。在默认情况下，FTP为ASCII码传输方式。
type：查看当前的传输方式
ascii：设定传输方式为ASCII码方式
binary：设定传输方式为二进制方式
（以上命令都不带参数）

get：下载指定文件get filename [newname](filename为下载的FTP服务器上的文件名，newname为保存在本都计算机上时使用的名字，如果不指定newname，文件将以原名保存。
get命令下载的文件将保存在本地计算机的工作目录下。该目录是启动FTP时在盘符C:后显示的目录。如果想修改本地计算机的工作目录，可以使用 lcd 命令。比如：lcd d:\ 表示将工作目录设定为D盘的根目录。

mget：下载多个文件mget filename [filename ....]（mget命令支持通配符“”和“?”，比如：mget .mp3 表示下载FTP服务器当前目录下的所有扩展名为mp3的文件。）

4.上传文件
put：上传指定文件put filename [newname]
send：上传指定文件send filename [newname]
（filename为上传的本地文件名，newname为上传至FTP服务器上时使用的名字，如果不指定newname，文件将以原名上传。）

上传文件前，应该根据文件的类型设置传输方式，本机的工作目录也应该设置为上传文件所在的目录。
这里的send和put方法用法都基本相同，但是上传速度send却要比put快很多，有兴趣的人可以去研究下。

5.结束并退出FTP
close：结束与服务器的FTP会话
quit：结束与服务器的FTP会话并退出FTP环境

6.其它FTP命令
pwd：查看FTP服务器上的当前工作目录
rename filename newfilename：重命名FTP服务器上的文件
deletefilename：删除FTP服务器上的文件
help[cmd]：显示FTP命令的帮助信息，cmd是命令名，如果不带参数，则显示所有FTP命令
```



### 客户端工具

Linux中

第一种

```shell
[root@localhost ~]# yum install ftp -y
[root@localhost ~]# ftp <IP地址>
Name (192.168.175.10:root):anonymous #匿名访问
password:直接回车
```

第二种

```shell
[root@localhost ~]# yum install lftp -y
[root@localhost ~]# lftp <IP地址>     # 默认使用匿名账户登录
```

区别：

ftp工具是一定要输入用户名称和密码的，登录成功或者失败会给出提示。lftp不会直接给出登录成功或者失败的

提示，需要输入ls工具才可以发现是否连接成功，优点在于连接更加方便

注意：ftp默认禁止root等用户登录，需要修改文件/etc/vsftpd/user_list



windows中

第一种 

在资源管理器中或者运行窗口中输入ftp://加ftp服务器地址

第二种

使用cmd窗口通过 ftp 服务器地址访问



### 主被动模式配置

#### 主动模式

在主动模式下，客户端告诉服务器使用哪个端口进行数据传输，服务器通过主动连接客户端的指定端口进行数据传输。

修改 `vsftpd` 配置文件

```bash
# 主动模式配置
connect_from_port_20=YES
```

#### 被动模式

在被动模式下，服务器告诉客户端使用哪个端口传输数据，客户端会主动连接到这些端口。被动模式更适合穿越防火墙的网络环境。

修改`vsftpd`配置文件，添加以下内容

```bash
# 被动模式配置
pasv_enable=YES
pasv_min_port=30000
pasv_max_port=31000            # 随机端口范围(但是会有些许误差)
```

#### 主被动切换测试

通过user01或者anonymous用户从客户端连接上来以后，通过passive切换主被动模式

```bash
[root@localhost ~]# ftp 192.168.88.10
Connected to 192.168.88.10 (192.168.88.10).
220 (vsFTPd 3.0.5)
Name (192.168.88.10:root): user01
331 Please specify the password.
Password:
230 Login successful.
Remote system type is UNIX.
Using binary mode to transfer files.
ftp> dir
227 Entering Passive Mode (192,168,88,10,120,145).    # 默认是被动模式，192,168,88,10,120,145 这里表示随机端口
150 Here comes the directory listing.
226 Directory send OK.
ftp> passive                                        # 通过passive切换主被动
Passive mode off.
ftp> dir
200 PORT command successful. Consider using PASV.    # 主动模式使用20做为数据端口，所以没有提示端口
150 Here comes the directory listing.
226 Directory send OK.
ftp>
```



### 案例

#### 案例1，匿名用户访问（默认开启）

```shell
[root@localhost ~]# vi /etc/vsftpd/vsftpd.conf
anonymous_enable=YES
anon_umask=022
anon_upload_enable=YES
anon_mkdir_write_enable=YES
anon_other_write_enable=YES
local_enable=YES
write_enable=YES
local_umask=022
dirmessage_enable=YES
xferlog_enable=YES
connect_from_port_20=YES
xferlog_std_format=YES
listen=NO
listen_ipv6=YES
pam_service_name=vsftpd
userlist_enable=YES
tcp_wrappers=YES
[root@localhost ~]# mkdir /share
[root@localhost ~]# echo "Hello anonymous user in /share" > /share/anonymous.txt
[root@localhost ~]# vim /etc/vsftpd/vsftpd.conf
[root@localhost ~]# systemctl restart vsftpd.service
linux的目录权限会限制我们不允许往里面新建文件，但是如果直接添加目录的w权限又会导致触发他的安全判断问题，所以就把ftp目录里的pub目录的属主和属主改为ftp解决，并且添加写权限
chown ftp.ftp /var/ftp/pub
chmod 777 /var/ftp/pub
现在就可以往里面写文件了
```

**客户端访问测试**

```bash
[root@localhost ~]# ftp 192.168.88.10
Connected to 192.168.88.10 (192.168.88.10).
220 (vsFTPd 3.0.5)
Name (192.168.88.10:root): anonymous
331 Please specify the password.
Password:
230 Login successful.
Remote system type is UNIX.
Using binary mode to transfer files.
ftp> ls
227 Entering Passive Mode (192,168,88,10,149,26).
150 Here comes the directory listing.
-rw-r--r--    1 0        0              31 Jan 04 02:49 anonymous.txt
226 Directory send OK.
ftp>
```



**客户端下载上传文件**

**server2中下载测试：**

```bash
ftp> get anonymous.txt
local: anonymous.txt remote: anonymous.txt
227 Entering Passive Mode (192,168,88,10,170,239).
150 Opening BINARY mode data connection for anonymous.txt (31 bytes).
226 Transfer complete.
31 bytes received in 3.5e-05 secs (885.71 Kbytes/sec)

[root@localhost ~]# cat anonymous.txt
Hello anonymous user in /share
```

**server2中上传测试：** 正常上传，会提示权限拒绝，匿名用户对该目录没有写入的权限，我们可以先赋予权限后尝试

```bash
# 创建测试文件
[root@localhost ~]# cat anonymous.txt
Hello anonymous user in /share
[root@localhost ~]# echo "put test" > server2.txt

# 上传测试
ftp> put server2.txt
local: server2.txt remote: server2.txt
227 Entering Passive Mode (192,168,88,10,60,195).
550 Permission denied.

# 赋予权限
[root@localhost share]# chmod 777 /share/
[root@localhost share]# chown ftp:ftp /share/

# 登录测试，但是会提示500错误
[root@localhost ~]# ftp 192.168.88.10
Connected to 192.168.88.10 (192.168.88.10).
220 (vsFTPd 3.0.5)
Name (192.168.88.10:root): anonymous
331 Please specify the password.
Password:
500 OOPS: vsftpd: refusing to run with writable root inside chroot()
Login failed.
421 Service not available, remote server has closed connection
ftp>
```

在 `vsftpd` 的默认配置下，匿名用户或任何用户被限制在 `chroot` 环境（即 FTP 根目录）时，`vsftpd` 不允许根目录拥有写权限。这是出于安全考虑，防止用户在根目录中执行潜在的危险操作。

而我们为共享目录赋予了 `777` 权限（可读、可写、可执行），导致根目录变成了“可写”，从而触发了 `vsftpd` 的安全检查。

所以，最佳实践是：我们在share目录中创建一个新的目录出来，以后以该目录做为操作目录

```bash
# 去除根目录的w权限
[root@localhost ~]# chmod a-w /share
# 新建目录并且赋予权限
[root@localhost ~]# mkdir /share/pub
[root@localhost ~]# chown 777 /share/pub
```

**server2登录上传测试：**

```bash
[root@localhost ~]# ftp 192.168.88.10
Connected to 192.168.88.10 (192.168.88.10).
220 (vsFTPd 3.0.5)
Name (192.168.88.10:root): anonymous
331 Please specify the password.
Password:
230 Login successful.
Remote system type is UNIX.
Using binary mode to transfer files.
ftp> cd pub                                        # 切换到pub目录
250 Directory successfully changed.
ftp> put server2.txt
local: server2.txt remote: server2.txt
227 Entering Passive Mode (192,168,88,10,230,206).
150 Ok to send data.
226 Transfer complete.
9 bytes sent in 4.8e-05 secs (187.50 Kbytes/sec)    # 上传成功

# server1中检查
[root@localhost ~]# cat /share/pub/server2.txt
put test
```



#### 案例2，本地用户访问

使用本地用户登录成功时位置在家目录的位置

```shell
[root@localhost ~]# vi /etc/vsftpd/vsftpd.conf
anonymous_enable=NO   
local_enable=YES
write_enable=YES
local_umask=022
dirmessage_enable=YES
xferlog_enable=YES
connect_from_port_20=YES
xferlog_std_format=YES
listen=NO
listen_ipv6=YES
pam_service_name=vsftpd
userlist_enable=YES
tcp_wrappers=YES
[root@localhost ~]# systemctl restart vsftpd
[root@localhost ~]# systemctl enable vsftpd
注意：出现在/etc/vsftpd/ftpusers  /etc/vsftpd/user_list这两个文件中的内容将会被定义为黑名单（无法使用FTP）
```



#### 案例3，虚拟用户访问

创建用于进行FTP认证的用户数据库文件，其中奇数行为账户名，偶数行为密码。

```bash
[root@localhost ~]# vim /etc/vsftpd/vuser.list
eagle
123456
admin
rockylinux
```

使用db_load命令用哈希（hash）算法将原始的明文信息文件转换成数据库文件，降低该文件的权限，避免其他用户看到文件的内容。最后删除原来的明文文件。确保信息安全。

```bash
# 先安装以下db_load工具
[root@localhost vsftpd]# yum install -y libdb-utils

# 加密vuser.list
[root@localhost ~]# cd /etc/vsftpd/
[root@localhost vsftpd]# db_load -T -t hash -f vuser.list vuser.db
[root@localhost vsftpd]# ll
total 36
-rw-------. 1 root root   125 Nov  7 01:49 ftpusers
-rw-------. 1 root root   361 Nov  7 01:49 user_list
-rw-------. 1 root root  5167 Jan  7 16:03 vsftpd.conf
-rwxr--r--. 1 root root   352 Nov  7 01:49 vsftpd_conf_migrate.sh
-rw-r--r--. 1 root root 12288 Jan  8 09:52 vuser.db
-rw-r--r--. 1 root root    30 Jan  7 16:52 vuser.list

# 查看文件描述以及修改权限
[root@localhost vsftpd]# file vuser.db
vuser.db: Berkeley DB (Hash, version 9, native byte-order)
[root@localhost vsftpd]# chmod 600 vuser.db
[root@localhost vsftpd]# rm -rf vuser.list
```

创建一个本地用户，用来做虚拟用户在本地的代理，为了安全起见，**禁止这个本地用户登录**

```bash
[root@localhost vsftpd]# useradd -d /var/ftproot -s /sbin/nologin virtual
[root@localhost vsftpd]# ls -ld /var/ftproot/
drwx------. 2 virtual virtual 62 Jan  8 14:11 /var/ftproot/
[root@localhost vsftpd]# chmod -Rf 755 /var/ftproot/
[root@localhost vsftpd]# ls -ld /var/ftproot/
drwxr-xr-x. 2 virtual virtual 62 Jan  8 14:11 /var/ftproot/
```

新建一个用于虚拟用户认证的PAM文件vsftpd.vu，利用pam模块（linux内核的一个认证模块）做一个认证

```bash
[root@localhost vsftpd]# vim /etc/pam.d/vsftpd.vu
auth required pam_userdb.so db=/etc/vsftpd/vuser
account required pam_userdb.so db=/etc/vsftpd/vuser
```

修改配置文件如下

```bash
[root@localhost vsftpd]# cat /etc/vsftpd/vsftpd.conf
anonymous_enable=NO
local_enable=YES
guest_enable=YES
guest_username=virtual
allow_writeable_chroot=YES
write_enable=YES
local_umask=022
dirmessage_enable=YES
xferlog_enable=YES
connect_from_port_20=YES
xferlog_std_format=YES
listen=NO
listen_ipv6=YES
pam_service_name=vsftpd.vu
# 记得修改这里为我们自己的认证文件
userlist_enable=YES
[root@localhost vsftpd]# systemctl restart vsftpd

# server2中访问测试
[root@localhost ~]# ftp 192.168.88.10
Connected to 192.168.88.10 (192.168.88.10).
220 (vsFTPd 3.0.5)
Name (192.168.88.10:root): eagle
331 Please specify the password.
Password:
230 Login successful.
Remote system type is UNIX.
Using binary mode to transfer files.
ftp> ls
227 Entering Passive Mode (192,168,88,10,249,41).
150 Here comes the directory listing.
226 Directory send OK.
```

用刚刚创建好的用户登录，但是只能登录，因为权限问题，不能写入文件

```bash
ftp> put anaconda-ks.cfg
local: anaconda-ks.cfg remote: anaconda-ks.cfg
227 Entering Passive Mode (192,168,88,10,220,169).
550 Permission denied.
```

针对不同的用户设置权限

```bash
[root@localhost vsftpd]# mkdir /etc/vsftpd/vusers_dir/
[root@localhost vsftpd]# cd /etc/vsftpd/vusers_dir/
[root@localhost vusers_dir]# vim eagle
anon_upload_enable=YES
anon_mkdir_write_enable=YES
anon_other_write_enable=YES

# 在主配置文件中导入子配置文件
[root@localhost vusers_dir]# vim /etc/vsftpd/vsftpd.conf
anonymous_enable=NO
local_enable=YES
guest_enable=YES
guest_username=virtual
allow_writeable_chroot=YES
write_enable=YES
local_umask=022
dirmessage_enable=YES
xferlog_enable=YES
connect_from_port_20=YES
xferlog_std_format=YES
listen=NO
listen_ipv6=YES
pam_service_name=vsftpd.vu
# 记得修改这里为我们自己的认证文件
userlist_enable=YES
# 告知子配置文件的路劲
user_config_dir=/etc/vsftpd/vusers_dir
[root@localhost vusers_dir]# systemctl restart vsftpd
```

server2中测试：

eagle用户可以写入，但是admin用户无法写入

```bash
[root@localhost ~]# ftp 192.168.88.10
Connected to 192.168.88.10 (192.168.88.10).
220 (vsFTPd 3.0.5)
Name (192.168.88.10:root): eagle
331 Please specify the password.
Password:
230 Login successful.
Remote system type is UNIX.
Using binary mode to transfer files.
ftp> put anaconda-ks.cfg
local: anaconda-ks.cfg remote: anaconda-ks.cfg
227 Entering Passive Mode (192,168,88,10,227,13).
150 Ok to send data.
226 Transfer complete.
905 bytes sent in 5.3e-05 secs (17075.47 Kbytes/sec)

# admin user
[root@localhost ~]# ftp 192.168.88.10
Connected to 192.168.88.10 (192.168.88.10).
220 (vsFTPd 3.0.5)
Name (192.168.88.10:root): admin
331 Please specify the password.
Password:
230 Login successful.
Remote system type is UNIX.
Using binary mode to transfer files.
ftp> ls
227 Entering Passive Mode (192,168,88,10,110,227).
150 Here comes the directory listing.
-rw-------    1 1001     1001          905 Jan 08 06:25 anaconda-ks.cfg
226 Directory send OK.
ftp> put anaconda-ks.cfg
local: anaconda-ks.cfg remote: anaconda-ks.cfg
227 Entering Passive Mode (192,168,88,10,89,240).
550 Permission denied.
# admin用户无法写入
```



## 三、NFS

Linux机器之间共享目录使用，共享出来的目录可以被其他机器挂载到本地

**应用场景：配置服务器文件共享，临时存储空间扩容（存储服务器）、集群数据集中化管理、数据持久化存储**

### NFS简介

NFS最早是希望可以把一台电脑的硬盘挂载到另一台电脑给另一台电脑用。如果想使用 ftp 资源的话，必须要下载到本地之后才可以打开，所以 ftp 的资源是一个纯网络资源，nfs 就可以直接打开共享的文件

NFS: Network File System 网络文件系统，基于内核的文件系统。 通过使用 NFS，用户和程序可以像访问本地文件一样访问远端系统上的文件，不过他是基于RPC协议的。NFS 的基本原则是“允许不同的客户端及服务端通过一组RPC分享相同的文件系统”，它是独立于操作系统，允许不同硬件及操作系统的系统共同进行文件的分享。可以理解为把一个电脑上的硬盘挂载到另一个电脑上使用，另一个电脑能够像使用自己本地硬盘使用挂载的硬盘。

RPC (Remote Procedure Call Protocol 远程过程调用) 采用 C/S 模式，客户机请求程序调用进程发送一个有进程参数的调用信息到服务进程，然后等待应答信息。在服务器端，进程保持睡眠状态直到调用信息到达为止。当一个调用信息到达,服务器获得进程参数,计算结果,发送答复信息，然后等待下一个调用信息，最后，客户端调用进程接收答复信息，获得进程结果，然后调用执行继续进行



#### RPC 远程过程调度

NFS 协议本身并没有网络传输功能，而是基于远程过程调用协议实现的，提供一个面向过程的远程服务的接口，可以通过网络从远程主机程序上请求服务，而不需要了解底层网络技术的协议，工作在 OSI 模型的会话层，它可以为遵从 RPC 协议应用层协议提供端口注册功能，事实上，有很多服务（NFS 和 NIS 等）都可以向 RPC 注册端口，RPC 使用网络端口 111 来监听客户端的请求



#### RPC 协议模型

1. 基于 rpc 的服务（此处是指 nfs 服务，在别处有可能是代表其他服务）在启动时向 portmapper 注册端口
2. 基于 rpc 的客户端联系服务端 portmapper 询问服务的端口号
3. portmapper 告知客户端基于 rpc 服务使用的端口号
4. 基于 rpc 的客户端访问被告知单某基于 rpc 服务的端口
5. 基于 rpc 的服务响应客户端的请求



#### NFS工作流程

1. 首先服务器端启动RPC服务，并开启111端口
2. 然后还需要服务器端启动NFS服务，并向RPC注册端口信息
3. 客户端启动RPC（portmap服务），向服务端的RPC(portmap)服务请求服务端的NFS端口
4. 服务端的RPC(portmap)服务反馈NFS端口信息给客户端。
5. 客户端通过获取的NFS端口来建立和服务端的NFS连接并进行数据的传输。



#### 挂载原理/过程

当我们在NFS服务器设置好一个共享目录/opt 后，其他人是有权访问/opt这个共享目录的，NFS客户端就可以将这个目录挂载到自己文件系统的某个挂载点（这个挂载点可以自己定义），路径不同也可以；并且挂载好后我们在本地能够看到服务端/opt下的所有数据。



#### NFS 软件介绍

- 软件包：nfs-utils
- 相关软件包：rpcbind(必须)，tcp_wrappers
- kernel 支持：nfs.ko
- 端口：2049(nfsd), 其它端口由 portmap(111)分配；（CentOS 6 开始 portmap 进程由 rpcbind 代替）
- NFS 服务主要进程
  - rpc.nfsd 最主要的 NFS 进程， 管理客户端是否可登录
  - rpc.mountd 挂载和卸载 NFS 文件系统，包括权限管理
  - rpc.lockd 非必要，管理文件锁,避免同时写出错
  - rpc.statd 非必要， 检查文件-致性， 可修复文件
  - 日志：/var/lib/nfs
- NFS 配置文件
  - /etc/exports
  - /etc/exports.d/*.exports



### NFS 部署

- 安装 nfs、rpcbind

```shell
[root@node2 ~]# yum -y install rpcbind nfs-utils   # 其实直接装nfs-utils也会以依赖的方式自动装上 rpcbind
```

- 启动 nfs 服务

```shell
[root@node2 ~]# systemctl start nfs-server         #或者开机启动 systemctl enable nfs-server
```

- 比较 nfs 启动前后的 rpcbind 的状态

```shell
[root@node2 ~]# systemctl status rpcbind.socket # nfs启动前，只是监听111端口，但是并没有启动对应的服务
[root@node2 ~]# systemctl status rpcbind  # nfs启动后，可以看到rpcbind自动启动了，也说明了nfs对rpc的依赖
```

- 查看已经监听的端口，在重启 nfs 之后，端口号会随机变化，所以需要 rpc 做注册

```shell
[root@node2 ~]# ss -ntulp
[root@node2 ~]# systemctl restart nfs
[root@node2 ~]# ss -ntulp
[root@node2 ~]# rpcinfo -p    # 可以查看到注册的端口号
```



### NFS 共享配置文件格式

```shell
/dir    主机 1(opt1,opt2)    主机 2(opt1,opt2)
```

- 主机格式
  - 单个主机: ipv4, ipv6, FQDN
  - IP networks: 两种掩码格式均支持
    - 172.18.0.0/255.255.0.0
    - 172.18.0.0/16
  - wildcards:主机名通配，例如*.iproute.cn，IP 不可以
  - netgroups: NIS 域的主机组，@group_ name
  - anonymous:表示使用*通配所有客户端
- 选项格式
  - 默认选项：(ro,sync,root_squash, no_all_squash)
  - ro, rw:只读和读写
  - async:异步，数据变化后不立即写磁盘，等磁盘空闲时再写入，性能高
  - sync:同步(1.0.0 后为默认)，数据在请求时立即写入共享存储磁盘
  - root_squash:远程 root 映射为 nfsnobody(默认)，UID 为 65534，Centos8 为 nobody, 早期版本是 4294967294 (nfsnobody)
  - no_root_squash:远程 root 映射成 root 用户
  - all_squash::所有远程用户(包括 root)都变成 nfsnobody , Centos8 为 nobody
  - no_all_squash:保留共享文件的 UID 和 GID (默认)
  - anonuid 和 anongid:指明匿名用户映射为特定用户 UID 和组 GID，而非 nfsnobody ,可配合 all_squash 使用



### NFS 工具

#### rpcinfo

rpcinfo 工具可以查看 RPC 相关信息

```shell
rpcinfo -p hostname   #查看注册在指定主机的 RPC 程序
rpcinfo -s hostname   #查看 rpc 注册程序
```



#### exportfs

```bash
exportfs -[选项]  # 可用于管理 NFS 导出的文件系统
```

常见选项：

- **-v**：查看本机所有 NFS 共享
- **-r**：重读配置文件，并共享目录
- **-a**：输出本机所有共享
- **-au**：停止本机所有共享
- **-u**:卸载某一个目录



#### showmount

常见用法：

```shell
showmount -e hostname   #查看服务器上的
```



#### mount.nfs

客户端 NFS 挂载

NFS 相关的挂载选项:`man 5 nfs`

- **fg**：(默认)前台挂载
- **bg**：后台挂载
- **hard**：(默认)持续请求
- **soft**：非持续请求
- **intr 和 hard 配合**：请求可中断
- **rsize 和 wsize**：一次读和写数据最大字节数，rsize=32768
- _**netdev**：无网络不挂载

提示:基于安全考虑，建议使用`nosuid,_netdev,noexec`挂载选项

例子:临时挂载 NFS 共享

```shell
mount -o rw,nosuid,fg,hard,intr 192.168.88.10:/myshare /mnt/nfs
```

例子:开机挂载

```shell
vim /etc/fstab
192.168.88.10:/myshare   /mnt/nfs    nfs    defaults,_netdev  0 0
```



#### 手动挂载案例

```bash
服务端
[root@localhost ~]# vim /etc/exports
/myshare 192.168.241.0/24
[root@localhost ~]# mkdir /myshare
[root@localhost ~]# cd /myshare
[root@localhost myshare]# echo "hello" > file
[root@localhost ~]# systemctl stop firewalld
[root@localhost ~]# setenforce 0

客户端：
[root@localhost ~]# yum -y install nfs-utils
[root@localhost ~]# showmount -e 192.168.241.128
Export list for 192.168.241.128:
# 虽然我们自己配置共享了，但是没有重读配置文件，所以读不到

服务端：
[root@localhost ~]# exportfs -r
exportfs: No options for /myshare 192.168.241.0/24: suggest 192.168.241.0/24(sync) to avoid warning
[root@localhost ~]# exportfs -v
/myshare        192.168.175.0/24(sync,wdelay,hide,no_subtree_check,sec=sys,ro,secure,root_squash,no_all_squash)

客户端：
[root@localhost ~]# showmount -e 192.168.241.128
Export list for 192.168.241.128:
/myshare 192.168.241.0/24
[root@localhost ~]# mkdir /mnt/nfs
[root@localhost ~]# mount -t nfs 192.168.241.128:/myshare /mnt/nfs
[root@localhost ~]# df -h
[root@localhost ~]# rm file
[root@localhost ~]# umount /mnt/nfs
现在是只读模式，想要修改模式要去改配置文件

服务端：
[root@localhost ~]# vim /etc/exports
/myshare 192.168.241.0/24(rw,sync,root_squash,no_all_squash)
[root@localhost ~]# exportfs -v
/myshare    192.168.241.0/24(sync,wdelay,hide,no_subtree_check,sec=sys,ro,secure,root_squash,no_all_squash)
[root@localhost ~]# exportfs -r
[root@localhost ~]# exportfs -v
/myshare       192.168.241.0/24(sync,wdelay,hide,no_subtree_check,sec=sys,rw,secure,root_squash,no_all_squash)

客户端：
[root@localhost ~]# showmount -e 192.168.241.128
Export list for 192.168.241.128:
/myshare 192.168.241.0/24
[root@localhost ~]# mount -t nfs 192.168.175.19:/myshare /mnt/nfs
[root@localhost ~]# df -h
[root@localhost ~]# cd /mnt/nfs/
[root@localhost nfs]# rm file
rm：是否删除普通空文件 "file"？y
rm: 无法删除"file": 权限不够
# 虽然给了rw权限，但是目录权限被linux控制

服务端：
[root@localhost ~]# ll -d /myshare/   #只显示当前目录自身，通常和-l搭配使用来显示当前目录自身的权限和属性信息
drwxr-xr-x. 2 root root 18 7月  16 21:56 /myshare/
[root@localhost ~]# chmod a+w /myshare
[root@192 myshare]# ll -d /myshare/
drwxrwxrwx. 2 root root 18 7月  16 21:56 /myshare/

客户端：
[root@localhost nfs]# rm file
rm：是否删除普通空文件 "file"？y
[root@localhost nfs]# echo "hello" >> file
[root@localhost nfs]# ll
总用量 4
-rw-r--r-- 1 nfsnobody nfsnobody 6 7月  16 22:08 file
[root@localhost nfs]# su - user01
[user01@localhost ~]$ cd /mnt/nfs/
[user01@localhost nfs]$ touch file1
[user01@localhost nfs]$ ll
总用量 4
-rw-r--r-- 1 nfsnobody nfsnobody 6 7月  16 22:08 file
-rw-rw-r-- 1 user01    user01    0 7月  16 22:11 file1
服务端：
[root@localhost myshare]# ll
总用量 4
-rw-r--r--. 1 nfsnobody nfsnobody 6 7月  16 22:08 file
-rw-rw-r--. 1      1000      1000 0 7月  16 22:11 file1
[root@localhost myshare]# useradd -u1000 zhangsan
[root@localhost myshare]# ll
总用量 4
-rw-r--r--. 1 nfsnobody nfsnobody 6 7月  16 22:08 file
-rw-rw-r--. 1 zhangsan  zhangsan  0 7月  16 22:11 file1
[root@localhost ~]# vim /etc/exports
/myshare 192.168.175.0/24(rw,sync,no_root_squash,all_squash)
[root@localhost myshare]# exportfs -r
[root@localhost myshare]# exportfs -v
/myshare        192.168.241.0/24(sync,wdelay,hide,no_subtree_check,sec=sys,rw,secure,no_root_squash,all_squash)
客户端：
[root@localhost ~]# umount /mnt/nfs/
[root@localhost ~]# mount -t nfs 192.168.241.128:/myshare /mnt/nfs
[root@localhost ~]# df -h
[root@localhost ~]# cd /mnt/nfs/
[root@localhost ~]# touch file{1,2,3}
[root@localhost nfs]# ll
总用量 4
-rw-r--r-- 1 nfsnobody nfsnobody 6 7月  16 22:08 file
-rw-rw-r-- 1 user01    user01    0 7月  16 22:11 file1
-rw-r--r-- 1 nfsnobody nfsnobody 0 7月  16 22:26 file2
-rw-r--r-- 1 nfsnobody nfsnobody 0 7月  16 22:26 file3
```



### 自动挂载

可使用autofs服务按需要挂载外围设备，NFS共享等，并在空闲5分钟后后自动卸载。主要用于客户端上，在客户端上自动挂载服务端提供的共享目录。



#### 相关包和文件

- 软件包: autofs
- 服务文件: /usr/lib/systemd/system/autofs.service
- 配置文件: /etc/auto.master



#### 配置autofs

`autofs` 的主要配置分为 **主配置文件** 和 **挂载映射文件**。

##### **主配置文件 `/etc/auto.master`**

`/etc/auto.master` 是 `autofs` 的主配置文件，用于定义挂载点及其对应的映射文件。

示例：

```bash
/mnt/nfs /etc/auto.nfs --timeout=300
```

配置说明：

- `/mnt/nfs`：挂载点的根目录。
- `/etc/auto.nfs`：挂载点对应的映射文件。
- `--timeout=300`：挂载超时时间（单位为秒），300 秒后未访问的挂载点将自动卸载。

**注意**：修改 `/etc/auto.master` 后需要重新加载 `autofs` 服务。

```bash
systemctl reload autofs
```



##### 挂载映射文件 `/etc/auto.nfs`

挂载映射文件定义了具体的 NFS 挂载规则。

示例：

```bash
share1    -fstype=nfs4,rw,soft    nfs-server:/export/share1
share2    -fstype=nfs4,ro,hard    nfs-server:/export/share2
```

配置说明：

- `share1` 和 `share2`：挂载点名称，最终挂载路径为 `/mnt/nfs/share1` 和 `/mnt/nfs/share2`。
- `-fstype=nfs4`: 指定文件系统类型为 NFSv4。
- `rw`/`ro`：挂载权限，`rw` 表示读写，`ro` 表示只读。
- soft/hard：
  - **soft**：如果 NFS 服务器未响应，客户端将返回错误。
  - **hard**：客户端将无限期尝试连接，直到服务器恢复正常。
- `nfs-server:/export/share1`：NFS 服务器地址及其共享路径。

**注意**：修改挂载映射文件后无需重启服务，`autofs` 会动态加载。



#### 挂载案例

一、创建挂载点目录

```bash
[root@localhost ~]# mkdir /mnt/nfs
```

二、配置autofs自动挂载

```bash
# 编辑auto.master主配置文件
[root@localhost ~]# vim /etc/auto.master
/mnt/nfs    /etc/auto.nfs
[root@localhost ~]# systemctl restart autofs

# 编辑挂载映射文件
[root@localhost ~]# vim /etc/auto.nfs
share   -fstype=nfs4,rw,soft    192.168.88.10:/myshare
```

三、验证挂载

```bash
# 访问挂载点以触发自动挂载
[root@localhost ~]# ls /mnt/nfs/share
dir  file  file1
[root@localhost ~]# cd /mnt/nfs/share/
[root@localhost share]# ls
dir  file  file1
[root@localhost share]# cat file
Hello, This is server2
```



#### 其他配置选项

在挂载映射文件中可以使用多种选项，以下是常用参数的详细说明：

##### 文件系统类型选项 (`-fstype=`)

- **nfs**：适用于 NFSv3 文件系统。
- **nfs4**：适用于 NFSv4 文件系统。

##### 挂载选项

- **rw**：读写权限。
- **ro**：只读权限。
- **soft**：允许客户端在超时后返回错误。
- **hard**：客户端会一直尝试连接，直到服务器恢复正常。
- **intr**：允许中断挂载操作（NFSv3 使用）。
- **timeo=**：超时时间（默认 600 分钟）。
- **bg**：后台挂载操作。

##### 变量支持

映射文件中可以使用变量。例如：

```bash
*   -fstype=nfs4,rw    192.168.88.10:/myshare/&
```

在此配置中，`*` 代表通配符，`&` 将被替换为对应挂载点名称。例如，访问 `/mnt/nfs/test` 时将挂载 `192.168.88.10:/myshare/test`



#### 配置文件格式

参看帮助: man 5 autofs

所有导出到网络中的NFS启用特殊匹配-host至"browse"

范例: /net目录可以自动挂载NFS共享

```shell
cat /etc/auto.master
/net    -hosts
cd /net/192.168.241.128
```

- 自动挂载资源有两种格式
  - 相对路径法:将mount point路径分成dirname和basename分别配置，可能会影响现有的目录结构
  - 绝对路径法:直接匹配全部绝对路径名称,不会影响本地目录结构



#### 相对路径法

- `/etc/auto.master`格式

```shell
挂载点的dirname    指定目录的配置文件路径
```

- 指定目录的配置文件格式

```shell
挂载点的basename    挂载选项    选项设备
```

案例:相对路径法为支持通配符

```shell
客户端：
[root@localhost ~]# vim /etc/auto.master
/misc    /etc/auto.misc
[root@localhost ~]# mkdir /misc 
[root@localhost ~]# vim /etc/auto.misc
# 表示/misc下面的子目录和nfs共享/export目录的子目录同名
* -fstype=nfs,vers=3 192.168.175.19:/myshare/&
[root@localhost ~]# systemctl restart autofs
服务端：
[root@localhost myshare]# mkdir -p dir/dir1
客户端：
[root@localhost ~]# df -h
[root@localhost misc]# ll /misc
总用量 0
[root@localhost misc]# cd /misc/dir
[root@localhost dir]# ll
总用量 0
drwxr-xr-x 2 root root 6 7月  17 19:10 dir1
[root@localhost dir]# df -h
```



#### 绝对路径法

- /etc/auto.master格式

```shell
/-      指定配置文件路径
```

- 指定配置文件格式

```shell
绝对路径      挂载选项      选项设备
```

案例:绝对路径法

```shell
[root@localhost dir]# vim /etc/auto.misc
#* -fstype=nfs,vers=3 192.168.175.19:/myshare/&
#把之前挂载的注释掉，防止重复挂载出问题
[root@localhost dir]# vim /etc/auto.master
/-      /etc/auto.direct
#添加一行，/-表示直接挂在根目录下
[root@localhost dir]# vim /etc/auto.direct
/nfsdir -fstype=nfs 192.168.175.19:/myshare
[root@localhost dir]# mkdir /nfsdir
[root@localhost dir]# systemctl restart autofs
[root@localhost dir]# df -h
[root@localhost ~]# cd /nfsdir/
[root@localhost ~]# df -h
```



### 实战案例

将NFS的共享目录，通过autofs 发布出来，做为远程主机用户的家目录

#### 环境准备

将server1中的用户家目录共享出来，server2在登录相同用户的时候，看到的家目录下的文件是一致的

#### 实验过程

一、NFS服务器(server1)创建用户和对应的目录，将用户user01的家目录共享出来

```bash
[root@localhost ~]# mkdir /data
[root@localhost ~]# useradd -d /data/user01 user01
[root@localhost ~]# id user01
uid=1000(user01) gid=1000(user01) groups=1000(user01)
[root@localhost ~]# vim /etc/exports
[root@localhost ~]# cat /etc/exports
# /myshare 192.168.88.0/24(rw,sync,root_squash,no_all_squash)
/data/user01 192.168.88.0/24(rw,sync,anonuid=1000,anongid=1000,all_squash)
[root@localhost ~]# exportfs -r
[root@localhost ~]# exportfs -v
/data/user01    192.168.88.0/24(sync,wdelay,hide,no_subtree_check,anonuid=1000,anongid=1000,sec=sys,rw,secure,root_squash,all_squash)
```

二、在NFS客户端(server2)中配置autofs

```bash
[root@localhost ~]# vim /etc/auto.master
/-  /etc/auto.user
[root@localhost ~]# vim /etc/auto.user
[root@localhost ~]# cat /etc/auto.user
/data/user01  -fstype=nfs4,rw,soft    192.168.88.10:/data/user01
[root@localhost ~]# systemctl restart autofs
```

三、在server2中创建user01用户

```bash
[root@localhost ~]# useradd -d /data/user01 -u 1000 user01
useradd: warning: the home directory /data/user01 already exists.
useradd: Not copying any file from skel directory into it.
```

四、测试

```bash
# 在server1中，登录到user01用户创建一个文件
[root@localhost ~]# su - user01
[user01@localhost ~]$ echo "The file is created by server1-user01" > file

# 在server2中，登录到user01用户查看是否共享了该文件
[root@localhost ~]# su - user01
[user01@localhost ~]$ ls
file
[user01@localhost ~]$ cat file
The file is created by server1-user01
[user01@localhost ~]$ pwd
/data/user01

# 检查server2中挂载情况
[user01@localhost ~]$ df -h
df: /mnt/nfs/share: Stale file handle
Filesystem                  Size  Used Avail Use% Mounted on
devtmpfs                    4.0M     0  4.0M   0% /dev
tmpfs                       872M     0  872M   0% /dev/shm
tmpfs                       349M  6.6M  343M   2% /run
/dev/mapper/rl-root          17G  1.7G   16G  10% /
/dev/nvme0n1p1              960M  261M  700M  28% /boot
tmpfs                       175M     0  175M   0% /run/user/0
192.168.88.10:/data/user01   17G  1.7G   16G  10% /data/user01
```



## 四、总结

1.远程管理ssh

ssh 用户名@IP -p 22 

什么是密钥对，以及如何使用密钥对进行登录



2.FTP：文件服务器

控制连接：21

数据连接：20

主动模式和被动模式的区别

最好熟练的部署FTP服务



3.NFS：特点：通过手动或者autofs自动挂载到本地，能够把远程的文件系统当作本使用

NFS并没有网络传输或者文件传输的功能，是由RPC协议来帮助nfs处理底层网络,。隐藏了复杂的TCP/IP协议原理



服务端：

配置文件 /etc/exports 

内容格式：/myshare		IP(具体配置)



客户端：

需要安装nfs-utils

showmount - e 服务端IP    #查看指定主机共享出来的东西



手动挂载：mount xxxx

/etc/fstab



自动挂载：安装软件包：autofs

步骤：编辑/etc/auto.masterr

编辑具体的目录配置文件

相对路径和绝对路径

注：自动挂载需触发才能显示出来
